<!DOCTYPE html>


<html lang="zh_CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta
        name="keywords"
        content="Java,迭代器,学习笔记,测试"
      />
       
      <meta name="description" content="第一次尝试配置Hexo, 难度挺大的" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Java集合类学习笔记第一章--迭代器 |  StarLu&#39;s Personal Blog Page</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="StarLu's Personal Blog Page" type="application/atom+xml">
</head>
  </html>
</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-collection_1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java集合类学习笔记第一章--迭代器
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/05/21/collection_1/" class="article-date">
  <time datetime="2021-05-20T16:00:00.000Z" itemprop="datePublished">2021-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0/">我的笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">5.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">21 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java集合类学习笔记第一章–迭代器"><a href="#Java集合类学习笔记第一章–迭代器" class="headerlink" title="Java集合类学习笔记第一章–迭代器"></a><center>Java集合类学习笔记第一章–迭代器</center></h1><h2 id="一-本章概述"><a href="#一-本章概述" class="headerlink" title="一. 本章概述"></a>一. 本章概述</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在本章中，主要介绍Java迭代器的有关内容。<br>
&emsp;&emsp;要讲集合，首先得讲清楚迭代器。在JDK中可以从接口声明中清楚的看到<a target="_blank" rel="noopener" href="https://doc
s.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>接口继承自</span>
<span style="font-size: 20px">
<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterable.html">Iterable</a>接口。<br>
&emsp;&emsp;而迭代器<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">
Iterator</a>接口</span>
<span style="font-size: 20px">,具体到其在各种集合类中对应的实现，为我们提供了有效地访问、遍历不同类型的集合中元素的方法。<br>
&emsp;&emsp;因此，我把对Iterable和Iterator这两个接口的学习放到了第一章。本章的学习目的为：</span>
<span style="font-size: 20px">
基本掌握Java迭代器在集合类当中的使用，同时对迭代器使用过程中的有关注意事项有一个清楚的认知。<br></span></div>

<span id="more"></span>

<h2 id="二-迭代器接口和可迭代接口的基本介绍"><a href="#二-迭代器接口和可迭代接口的基本介绍" class="headerlink" title="二. 迭代器接口和可迭代接口的基本介绍"></a>二. 迭代器接口和可迭代接口的基本介绍</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;根据官方API中对Iterable可迭代接口的说明:"Implementing this interface allows an object to be the target </span>
<span style="font-size: 20px">of the "for-each loop" statement."，实现了Iterable接口的对象就可以使用for-each循环。那么，</span>
<span style="font-size: 20px">什么是for-each循环呢?<br>
&emsp;&emsp;for-each循环，又称增强for循环，是JDK5的新特性中定义的一种新的循环语法，语法的标准格式为：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for( 数据类型 变量名 : 遍历的目标对象 ) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;最常见的比如数组就支持for-each循环，以下是用普通for循环和增强for循环对数组遍历的示例程序：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void loopTest() &#123;</span><br><span class="line">    int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">    System.out.println(&quot;普通for循环:&quot;);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;\n增强for循环:&quot;);</span><br><span class="line">    for(int num : arr) &#123;</span><br><span class="line">        System.out.print(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="font-size: 20px">&emsp;&emsp;执行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/20/gIgQP0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;根据官方API，Iterable接口中的定义为：<code>public Interface Iterable&lt;T&gt;</code>，内部的抽象方法只有一个:</span>
<span style="font-size: 20px"><code>Iterator&lt;T&gt;iterator()</code></span>
<span style="font-size: 20px">其作用为返回一个元素类型为T的迭代器。所有实现了Iterable的接口都实现了这个方法，特别的，集合也是。<br>
&emsp;&emsp;接着我们看看Iterator接口的API，接口定义为：<code>public Interface Iterator<&#917;></code>。官方文档对其有如下的解释：
<br>&emsp;&emsp;Iterator是用来替代原来集合框架中的<a href="">Enumeration</a>接口的，</span>
<span style="font-size: 20px">其相比Enumeration接口，有以下两个变化：其一是迭代器允许调用者在迭代过程中使用定义明确的语义</span>
<span style="font-size: 20px">从集合中删除元素；其二是对方法的命名有所改进。第一点中所谓定义明确的语义，听起来有点费解</span>
<span style="font-size: 20px">我们会在接下来的小节研究这一部分的内容，这里就先跳过了。<br>
&emsp;&emsp;Iterator中声明了两个抽象方法和两个默认方法，其中最重要也是最常用的三个方法分别为：<br>
&emsp;&emsp;<code>boolean hasNext()</code> ，作用为判断迭代是否还有下一个元素。换句话说，当该方法返回true时，调用next方法</span>
<span style="font-size: 20px">会返回下一个元素而不是抛出异常<br>
&emsp;&emsp;<code>E    next()</code> ，作用为返回迭代的下一个元素，如果迭代已经没有下一个元素了，则会抛出NoSuchElementException。<br>
&emsp;&emsp;<code>default void remove()</code> ，作用为从集合中移除此迭代器最近返回的那个元素。</span>
<span style="font-size: 20px">关于该默认方法有一些注意事项，我们会在第三小节中详细说明。<br></span>
</div>


<h2 id="三-Iterator接口的详细介绍"><a href="#三-Iterator接口的详细介绍" class="headerlink" title="三. Iterator接口的详细介绍"></a>三. Iterator接口的详细介绍</h2><div style="font-size: 20px">
&emsp;&emsp;下面仔细研究一下Iterator接口中的这三个方法，使用集合类中大家最熟悉的ArrayList做测试。<br></div>

<h3 id="part1–hasNext方法"><a href="#part1–hasNext方法" class="headerlink" title="part1–hasNext方法"></a>part1–hasNext方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns true if the iteration has more elements.</mark></span>
<span style="font-size: 20px"><mark>(In other words, returns true if next() would return an element
rather than throwing an exception.)</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void hasNextTest() &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">        Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        arraylist.add(1);</span><br><span class="line">        &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">        it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;空迭代器调用hasNext方法会抛出NullPointerException</span><br><span class="line">        ArrayList&lt;Integer&gt; null_arr &#x3D; null;</span><br><span class="line">        Iterator&lt;Integer&gt; null_it &#x3D; null_arr.iterator();</span><br><span class="line">        System.out.println(null_it.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZYnA.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，第一次获取arraylist的迭代器的时候，arraylist为空，所以it.hasNext输出为false; 而第二次获取arraylist</span>
<span style="font-size: 20px">迭代器的时候，arraylist中有一个元素1，所以it.hasNext输出为true; 接着我们定义了一个空的ArrayList对象，</span>
<span style="font-size: 20px">获得了它的迭代器，此时这个迭代器为空，若对空迭代器调用hasNext方法，则会产生NullPointerException异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part2–next方法"><a href="#part2–next方法" class="headerlink" title="part2–next方法"></a>part2–next方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns the next element in the iteration.</mark></span>
<span style="font-size: 20px"><mark>Throws NoSuchElementException if the iteration has no more elements.</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void nextTest() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line"></span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果it.hasNext()为false的时候调用it.next会产生NoSuchElementException</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZIc4.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在while循环的循环判断中，我们使用it.hasNext()来判断迭代是否有下一个元素，当迭代有下个元素的时候，</span>
<span style="font-size: 20px">我们再调用it.next()，此时可以保证it.next()返回的是下一个元素而不会抛出异常。</span>
<span style="font-size: 20px"><mark>这也是一种标准的非常建议的迭代器的使用方法</mark>，我们会在第四节中再提及这一点。<br>
&emsp;&emsp;根据打印结果，说明每次调用next()方法，在得到下一个元素的同时，迭代器的位置都会发生移动，使得下一次调用next()方法的时候</span>
<span style="font-size: 20px">迭代的下一个元素(如果有的话)是当前next()返回元素的下一个。具体到示例程序中，就是依次返回1、2、3。<br>
&emsp;&emsp;接着，程序退出while循环，说明hasNext()返回值为false，此时迭代到了末尾，已经没有下一个元素了，如果此时调用next()方法</span>
<span style="font-size: 20px">就会像API中规定的那样，抛出NoSuchElement异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part3–remove方法"><a href="#part3–remove方法" class="headerlink" title="part3–remove方法"></a>part3–remove方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Removes from the underlying collection
the last element returned by this iterator (optional operation). This method can be called only
once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified 
while the iteration is in progress in any way other than by calling this method.</mark></span>
<span style="font-size: 20px"><mark>Throws:UnsupportedOperationException if the remove operation
is not supported by this iterator. Throws IllegalStateException if the next method has not yet 
been called, or the remove method has already been called after the last call to the next method.</mark><br>
&emsp;&emsp;这个说明文档非常长，里面涉及的值得注意的地方也很多，其中最关键的便是以下四点：<br>
&emsp;&emsp;(1) remove()删除的是该迭代器最近返回的元素，即上一次调用next()返回的那一个元素。<br>
&emsp;&emsp;(2) 每次调用next()后，至多调用一次remove()，否则会抛出IllegalStateException异常。<br>
&emsp;&emsp;(3) 不能未经调用next()就直接调用remove()，否则也会抛出IllegalStateException异常。<br>
&emsp;&emsp;(4) 如果在迭代正在进行中以除调用该remove()方法之外的任何方式修改这个集合，则迭代器的行为未定义。<br>
&emsp;&emsp;我们来研究测试一下第(4)，这有助于我们理解为什么在很多集合类比如ArrayList本身拥有remove()方法的前提下，JDK</span>
<span style="font-size: 20px">在Iterator中还要提供迭代器专有的remove()方法：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void removeTest1() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中不删除元素</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中正确使用Iterator专有的remove()方法删除元素</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(&quot;当前迭代元素：&quot; + it.next());</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;***************************************&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此时arraylist中的所有元素都在迭代的过程中被迭代器的remove()方法正确删除了</span><br><span class="line">    System.out.println(arraylist.size());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;***************************************&quot;);</span><br><span class="line"></span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line">    &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中错误使用ArrayList类中的remove()方法删除元素，注意，这是绝对不建议的行为</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        Integer ele &#x3D; it.next();</span><br><span class="line">        System.out.println(&quot;当前迭代元素：&quot; + ele);</span><br><span class="line">        &#x2F;&#x2F;能删除成功，但是删除成功后迭代器将产生API中未定义的行为</span><br><span class="line">        System.out.println(arraylist.remove(ele));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g71enU.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，示例程序在第一部分展现的是正常的迭代并输出，在迭代的过程中我们没有使用任何的删除方法。第二部分中，在while循环里</span>
<span style="font-size: 20px">每调用一次next()方法后，我们调用一次Iterator专有的remove()方法删除集合中的元素，最后迭代结束后打印</span>
<span style="font-size: 20px">arraylist的元素个数，发现是0。并且整个迭代过程中并没有抛出任何异常，说明我们的使用是正确的。实际上，</span>
<span style="font-size: 20px"><mark>这是我们极其建议的API中规定的使用方法</mark>。<br>
&emsp;&emsp;反之，在第三部分中，我们尝试进行跟第二部分几乎一样的过程，唯一的不同在于删除元素的时候，我们尝试使用ArrayList中</span>
<span style="font-size: 20px">的remove方法而不是迭代器的remove方法。<mark>这是我们极不建议的方法</mark>，</span>
<span style="font-size: 20px">事实上，这回导致(4)中的严重问题。执行结果表明在第一次删除元素1之后，再次进入循环后，调用</span>
<span style="font-size: 20px">迭代器next方法时发生了错误，抛出了ConcurrentModificationException异常。</span>
<span style="font-size: 20px">应当是错误的删除操作破坏了迭代器的结构，使得迭代器无法按照其具体实现的代码逻辑正常执行功能。<br>
&emsp;&emsp;<mark>所以在使用迭代器迭代的过程中，务必遵照API的要求，只能使用迭代器中提供的方法修改集合的元素。</mark><br>
&emsp;&emsp;接下来我们来看看(2)和(3)的测试：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void removeTest2() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;测试调用1次next()后调用2次remove(),会抛出IllegalStateException异常</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    it.remove();</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void removeTest3() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;测试未调用next()直接调用remove(),也会抛出IllegalStateException异常</span><br><span class="line">    it.remove();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果分别如下：<br></span><br><span style="font-size: 20px">&emsp;&emsp;removeTest2()：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7Gf4H.png" alt="illustration_1"><br><br><br><span style="font-size: 20px">&emsp;&emsp;removeTest3()：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7G58A.png" alt="illustration_2"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，示例程序removeTest2在调用1次next()后调用2次remove(),会按(2)中所说的那样，</span>
<span style="font-size: 20px">抛出IllegalStateException异常。而示例程序removeTest3在未调用next()时直接调用</span>
<span style="font-size: 20px">remove()方法,会按(3)中所说的那样，也会抛出一个IllegalStateException异常。<br>
&emsp;&emsp;因此，在使用迭代器的remove的方法时，一定要确保调用remove()前要先调用next(),并且每调用一次next()，</span>
<span style="font-size: 20px">最多只能调用一次remove()。<br>
&emsp;&emsp;举个形式化的例子，设n的初始值为0，在集合元素足够多的情况下，每调用一次next()使n的值置为1，而每调用一次remove()使n减小1，</span>
<span style="font-size: 20px">一个合法的调用序列需要满足任意时刻n的值非负。<br>
&emsp;&emsp;比如next()->next()->remove()->next()->remove()->next()就是一个合法的调用序列，对应n的变化为：</span>
<span style="font-size: 20px">0->1->1->0->1->0->1。而next()->next()->remove()->next()->remove()->remove()</span>
<span style="font-size: 20px">就是一个非法的调用序列对应n的变化为：</span>
<span style="font-size: 20px">0->1->1->0->1->0->-1(非法)。<br></span></div>

<h2 id="四-for循环、for-each循环与迭代器"><a href="#四-for循环、for-each循环与迭代器" class="headerlink" title="四. for循环、for-each循环与迭代器"></a>四. for循环、for-each循环与迭代器</h2><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;到目前未知，我们一共有三种备选的方法可以用于对集合对象进行循环遍历，分别为：for循环、for-each循环(enhanced-for循环)</span>
<span style="font-size: 20px">与使用对应的迭代器迭代。我们首先各自分析它们的特点，然后进行对比分析，尝试得出对比的结论。<br></span></div>

<h3 id="part1–for循环"><a href="#part1–for循环" class="headerlink" title="part1–for循环"></a>part1–for循环</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;for循环十分简单，我们经常在数组循环的时候使用这种方法，以下是一段非常常见的for循环代码：<br>
</span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void forloopTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            Integer now &#x3D; arraylist.get(i); &#x2F;&#x2F;顺序结构的arraylist的for循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            Integer now &#x3D; linkedlist.get(i); &#x2F;&#x2F;链式结构的linklist的for循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;for循环示例程序中的内层for循环的平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7XVkn.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在该for循环示例程序中我们先通过一系列手段声明并初始化两个长度10000的List,其中一个是顺序结构的arraylisr，</span>
<span style="font-size: 20px">另一个是链式结构的linkedlist。接着进行100次相同的循环，每次外循环里都嵌套两个内循环，内循环里分别依次获得这</span>
<span style="font-size: 20px">两个List各自对应下标的元素。最后分别打印出两种结构这100次内层for循环的平均执行时间。</span>
<span style="font-size: 20px">结果为：<mark>顺序结构为0.01ms，链式结构为33.65ms</mark>,这个数据在接下来我们做对比的时候还会用到。<br>
</span></div>

<h3 id="part2–for-each循环"><a href="#part2–for-each循环" class="headerlink" title="part2–for-each循环"></a>part2–for-each循环</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;IDEA有时会提醒你可以for-each循环替代某些for循环，这应当是有其内在原因的，以下是一段与part1中对应代码逻辑一致代码</span>
<span style="font-size: 20px">只不过内层循环的实现采用了for-each循环：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void forEachloopTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(Integer ele : arraylist) &#123;</span><br><span class="line">            Integer now &#x3D; ele; &#x2F;&#x2F;顺序结构的arraylist的forEach循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(Integer ele : linkedlist) &#123;</span><br><span class="line">            Integer now &#x3D; ele; &#x2F;&#x2F;链式结构的linklist的forEach循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;forEach循环示例程序中的内层forEach循环的平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7vTS0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，该forEach循环示例程序与for循环示例程序基本一样，只不过循环的方式改成了for-each循环</span>
<span style="font-size: 20px">最后分别打印出两种结构这100次内层for循环的平均执行时间。结果为：</span>
<span style="font-size: 20px"><mark>顺序结构为0.18ms，链式结构为0.08ms</mark>,这个数据在接下来我们做对比的时候还会用到。<br></span></div>

<h3 id="part3–迭代器"><a href="#part3–迭代器" class="headerlink" title="part3–迭代器"></a>part3–迭代器</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;而我们之前讲的迭代器呢？它与for循环和forEach循环直接有什么关系，来看下面一段示例程序，</span>
<span style="font-size: 20px">同样，与par1和part2中的代码相比，par3中程序只是将原本的内层循环改为了迭代器迭代：<br></span></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void iterationTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; arr_it &#x3D; arraylist.iterator();</span><br><span class="line">        Iterator&lt;Integer&gt; link_it &#x3D; linkedlist.iterator();</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        while(arr_it.hasNext()) &#123;</span><br><span class="line">            Integer now &#x3D; arr_it.next(); &#x2F;&#x2F;顺序结构的arraylist的迭代</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        while(link_it.hasNext()) &#123;</span><br><span class="line">            Integer now &#x3D; link_it.next();&#x2F;&#x2F;链式结构的linklist的迭代</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;迭代示例程序中的迭代平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7zorT.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，该迭代示例程序与for循环示例程序和for-each循环示例程序基本一样，只不过把循环改成了迭代</span>
<span style="font-size: 20px">最后分别打印出两种结构这100次内层for循环的平均执行时间。结果为：</span>
<span style="font-size: 20px"><mark>顺序结构为0.03ms，链式结构为0.1ms</mark>,这个数据在接下来我们做对比的时候还会用到。<br></span></div>

<h3 id="part4–对比分析"><a href="#part4–对比分析" class="headerlink" title="part4–对比分析"></a>part4–对比分析</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;首先根据我们在part1、part2、part3中的示例程序的运行结果，<mark>从效率上分析</mark>这三种方法的异同：<br>
&emsp;&emsp;<mark>对于顺序结构来说，不论是直接采用for循环，还是采用for-each循环或者迭代器来遍历，效率都是很高的。</mark></span>
<span style="font-size: 20px">原因在于：顺序结构实现的Array或者ArrayList都支持随即检索，按下标查找任何一个位置元素的效率都是常数，</span>
<span style="font-size: 20px">而与位置无关。<br>
&emsp;&emsp;<mark>而对于链式结构来说，采用迭代器或是for-each循环遍历的效率远远高于采用普通的for循环。</mark></span>
<span style="font-size: 20px">原因是普通for循环中调用的get方法，对于链式结构无法采用随机访问的方式寻址，只能通过顺序访问的方式找到对应位置</span>
<span style="font-size: 20px">的链表元素，效率与元素所在位置有关，并不是常数。而用for-each循环和迭代的时候，其内部的实现机制能够</span>
<span style="font-size: 20px">使得访问元素的效率为常数，因此效率很高。<br>
&emsp;&emsp;总而言之就是：</span><span style="font-size: 20px">
<mark>对于链式结构的集合，建议采用for-each循环和迭代器进行遍历；对于顺序结构的集合，几种方法在效率上无明显差距。</mark>此外，</span>
<span style="font-size: 20px">对于HashMap、HashSet等元素没有下标的集合，根本无法使用for循环进行遍历，就只能用后两种方法了。<br>
&emsp;&emsp;而关于迭代和for-each循环的异同，我们可以作如下总结：<br>
&emsp;&emsp;for-each本身的实现其实还是在内部使用的迭代器，只不过for-each循环的语法比迭代器简洁。</span><span style="font-size: 20px">
而迭代器的优势在于，<mark>如果需要在遍历的过程中修改、删除元素的话，就必须使用迭代器。</mark><br></span></div>



<h2 id="五-ListIterator简介"><a href="#五-ListIterator简介" class="headerlink" title="五. ListIterator简介"></a>五. ListIterator简介</h2><p><span style="font-size: 20px">&emsp;&emsp;To Be Continued!<br></span></p>
<h2 id="六-参考资料"><a href="#六-参考资料" class="headerlink" title="六. 参考资料"></a>六. 参考资料</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterable.html">Java JDK8官方API Iterable</a><br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">Java JDK8官方API Iterator</a><br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/
api/java/util/ListIterator.html">Java JDK8官方API Iterator</a><br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/
details/52743564">Java 集合源码解析(1)：Iterator</a>&emsp;&emsp;作者：拭心<br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://shixin.blog.csdn.net/article/
details/52752589">Java 集合源码解析(2)：ListIterator</a>&emsp;&emsp;作者：拭心<br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/Jae_Wang/
article/details/80526216">Java迭代器(iterator详解以及和for循环的区别)</a>&emsp;&emsp;作者：Jae_Wang<br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/import_sadaharu/
article/details/78906160">List逆向遍历、反向遍历--Iterator详解</a>&emsp;&emsp;作者：萨达哈鲁君<br>
&emsp;&emsp;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/193139479">聊聊Java中的迭代器</a>&emsp;&emsp;作者：helloworld2017<br></span>
</div>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://starlooo.github.io/2021/05/21/collection_1/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/" rel="tag">迭代器</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2021/05/19/collection_0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Java集合类学习笔记序章</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "6zcqIYAuSsa8BxuxqpwafQSf-gzGzoHsz",
    app_key: "G7i7gWhHfoVw5etXVAhF4UFD",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> StarLu
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/myside.svg" alt="StarLu&#39;s Personal Blog Page"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2021/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>