<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>软件构造课程随笔--UML类图</title>
    <url>/2021/06/02/SuiBi1/</url>
    <content><![CDATA[<h1 id="软件构造课程随笔–UML类图"><a href="#软件构造课程随笔–UML类图" class="headerlink" title="软件构造课程随笔–UML类图"></a><center>软件构造课程随笔–UML类图</center></h1><h2 id="一-写在前面"><a href="#一-写在前面" class="headerlink" title="一. 写在前面"></a>一. 写在前面</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在软件构造课程中，我们讲三维度，八视图。其中build-time，code-level，moment view中就包含了Class Diagram，也就是类图。<br>
&emsp;&emsp;UML类图是一种常见的绘制JAVA类图的工具，<mark>能够看懂类图对于理解大型的JAVA程序的结构，以及理解各种各样的设计模式的思路都非常重要。</mark></span>
<span style="font-size: 20px">
首先简要介绍一下UML是什么：根据</span>
<span style="font-size: 20px">
<a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fromtitle=UML&fromid=446747&fr=aladdin">
百度百科UML词条</a>的有关内容，统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、</span>
<span style="font-size: 20px">
可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。<br>
&emsp;&emsp;UML的概念包括了UML语义（Semantics）和UML表示符（Notation）两个部分。UML语义定义了静态模型和动态模型。</span>
<span style="font-size: 20px">
结构模型强调系统的对象结构，入对象的类、接口、属性和关系；行为模型关注的是系统对象的行为动作，如对象的方法、交互、协作和状态。</span>
<span style="font-size: 20px">
UML表示符为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准。重要内容由9种图来定义，包括用例图、类图、对象图、状态图、
</span>
<span style="font-size: 20px">
构件图、部署图、协作图、交互序列图、活动图。<br>
&emsp;&emsp;以上是对UML的简要介绍，还是比较抽象的，由于目前阶段我们并不涉及到整个UML统一建模语言的详细介绍，而是只是专注于</span>
<span style="font-size: 20px">
介绍UML类图这一部分内容，因此无需对UML本身做出过多的了解，这部分内容超出了软件构造课程的范围，这里我们只是简单地引入一些。</span>
<span style="font-size: 20px">
值得注意的是，<mark>本文旨在介绍UML类图的要素，目的是教会读者如何理解一个UML类图，并不涉及UML类图的绘制</mark>，关于如何绘制UML类图，</span>
<span style="font-size: 20px">
以及有关工具在最后部分，我会罗列一些参考博客，可以供想要进一步了解的读者自行学习。<br></span></div>


<span id="more"></span>

<h2 id="二-UML类图的基本结构"><a href="#二-UML类图的基本结构" class="headerlink" title="二. UML类图的基本结构"></a>二. UML类图的基本结构</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;UML的基本结构是：对于每个类，采用一个矩形方框来表示，整个矩形方框分为三部分的小矩形，最上方是该类的类名；中间表示该类的属性；
</span>
<span style="font-size: 20px">
最下方是该类的方法。如下图所示是一个类在类图中的表示：</span></div>

<p><img src="https://z3.ax1x.com/2021/07/05/R5qWHs.png" alt="illustration_1"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;可以看到，该类的类名叫做GeelyClass，有五个属性：String型的name，int型的age，double型的weight，</span>
<span style="font-size: 20px">
double型的height和char型的sex。以及一系列的方法。<br>
&emsp;&emsp;我们可以看到有以下一些符号或者格式，它们的含义分别如下：<br></span>
<span style="font-size: 20px">
&emsp;&emsp; ① "+"号修饰，表示属性或者方法的访问权限是public。<br>
&emsp;&emsp; ② "-"号修饰，表示属性或者方法的访问权限是private。<br>
&emsp;&emsp; ③ "#"号修饰，表示属性或者方法的访问权限是protected。<br>
&emsp;&emsp; ④ "~"号修饰，表示属性或者方法的访问权限是default。<br>
&emsp;&emsp; ⑤ 下划线修饰，表示属性或者方法是静态的。<br>
&emsp;&emsp; ⑥ 字体为斜体，表示属性或者方法是抽象的。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;例如：GeelyClass的属性age是private的，属性sex是public static的，drink()方法是protected的等等。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;以上便是对单个类的UML类图表示的信息的基本介绍，还是比较简单的。</span></div>

<h2 id="三-UML类图中类与类的关系"><a href="#三-UML类图中类与类的关系" class="headerlink" title="三. UML类图中类与类的关系"></a>三. UML类图中类与类的关系</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;UML类图除了可以用来表示一个类的属性和方法以外，更重要的功能是来表示不同的类之间的联系，这种联系一共分为：泛化、实现、关联、</span>
<span style="font-size: 20px">
聚合和组合共五种。我们来一一介绍它们的概念以及是如何在UML类图被表示的：<br>
&emsp;&emsp;第一种是<mark>泛化</mark>，用于表示类与类之间的继承关系，或者接口与接口之间的继承关系，以及类与接口之间的实现关系</span>
<span style="font-size: 20px">
即泛化分为继承和实现两种类型。<mark>在UML类图中，使用空心三角+实线连接来表示继承关系而使用空心三角+虚线连接来表示实现关系</mark>，如下图所示：</span>
</div>

<p><img src="https://z3.ax1x.com/2021/07/05/RIkdbt.png" alt="illustration_2"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;第二种是<mark>依赖</mark>，对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依靠另一个对象的服务时，</span>
<span style="font-size: 20px">
这两个对象之间主要体现为依赖关系。</span>
<span style="font-size: 20px">
<mark>在UML类图中，使用虚线箭头来表示依赖关系</mark>，如下图所示：</span>
</div>

<p><img src="https://z3.ax1x.com/2021/07/05/RIAwQJ.png" alt="illustration_3"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;第三种是<mark>关联</mark>，对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</span>
<span style="font-size: 20px">
<mark>在UML类图中，使用实线箭头来表示关联关系</mark>，如下图所示：</span>
</div>

<p><img src="https://z3.ax1x.com/2021/07/05/RIABLR.png" alt="illustration_4"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;第四种是<mark>聚合</mark>，表示一种弱的拥有关系，即has-a的关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，两个对象具有各自的生命周期。</span>
<span style="font-size: 20px">
<mark>在UML类图中，使用空心的菱形+实线箭头来表示聚合关系</mark>，如下图所示：</span>
</div>

<p><img src="https://z3.ax1x.com/2021/07/05/RIATTP.png" alt="illustration_5"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;第五种是<mark>组合</mark>，组合是一种强的拥有关系，是一种contains-a的关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。</span>
<span style="font-size: 20px">
<mark>在UML类图中，使用实心的菱形+实线箭头来表示聚合关系</mark>，如下图所示：</span>
</div>

<p><img src="https://z3.ax1x.com/2021/07/05/RIEemR.png" alt="illustration_6"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;以上便是对UML类图是如何表示类与类之间关系的介绍。</span></div>

<h2 id="四-一个举例"><a href="#四-一个举例" class="headerlink" title="四. 一个举例"></a>四. 一个举例</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;以老师在第一讲PPT给出的类图为示例，总结一下：</span></div>

<p><img src="https://z3.ax1x.com/2021/07/05/RIEWNV.png" alt="illustration_7"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;如上图所示，我们可以发现在这个大UML类图里，我们之前讲的都有涉及到。<br>
&emsp;&emsp;首先是属性和方法，可以看到Generator接口</span>
<span style="font-size: 20px">
没有属性，符合其接口的特征；其所有方法都是用"+"修饰的，代表访问权限public，并且都是斜体的，表示这些方法是抽象的，同样也符合接口的定义。</span>
<span style="font-size: 20px">
然后我们再看看AbstractConvert抽象类，可以看到它的类名是斜体的，并且有两个"-"修饰的私有属性。</span><br>
<span style="font-size: 20px">
&emsp;&emsp;然后是彼此之间的关系，可以看到抽象类AbstractGenerator实现了Generator接口，在类图中用空心三角+虚线表示；而它又有两个子类继承它，在类图中用空心三角+实线表示</span>
<span style="font-size: 20px">
除此之外，我们还可以看到，AbstractConvertor抽象类与Generator接口之间有组合关系，在类图中用实心菱形+实线表示。</span><br>
<span style="font-size: 20px">
&emsp;&emsp;该UML类图中没有涉及到依赖关系、关联关系和聚合关系。</span></div>

<h2 id="五-一个实用的画UML类图的工具"><a href="#五-一个实用的画UML类图的工具" class="headerlink" title="五. 一个实用的画UML类图的工具"></a>五. 一个实用的画UML类图的工具</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;最后推荐一个方便的<a href="https://www.processon.com/">画图网站</a>，除了可以画UML图外，还有许多其他的强大功能。请有兴趣的读者自行摸索！
</span><br>
<span style="font-size: 20px">
&emsp;&emsp;以上便是对UML类图的简单介绍，本篇随笔到此结束。感谢阅读，再见！</span>
</div>
]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>软件构造</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类学习笔记序章</title>
    <url>/2021/05/19/collection_0/</url>
    <content><![CDATA[<h1 id="Java集合类学习笔记序章"><a href="#Java集合类学习笔记序章" class="headerlink" title="Java集合类学习笔记序章"></a><center>Java集合类学习笔记序章</center></h1><h2 id="一-系列简介"><a href="#一-系列简介" class="headerlink" title="一. 系列简介"></a>一. 系列简介</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在软件构造课程的学习过程中，对Java编程语言的不断</span>
<span style="font-size: 20px">
学习和练习是至关重要的。其中，通过对于Java JDK当中提供的各种各</span>
<span style="font-size: 20px">
样的容器的使用方法的学习能够极大地提高我们的编程能力。而JDK中</span>
<span style="font-size: 20px">
最常用的一类容器，莫过于<a href="https://docs.oracle.com/javase
/8/docs/api/java/util/Collection.html">集合Collection</a>了。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;因此，在学习Java Collection接口以及各个常见的实现类的过程当</span>
<span style="font-size: 20px">
中，撰写一系列博客来记录学习的过程和心得体会是有必要的。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;然而，由于Java集合及其各种实现类源码本身涉及到复杂的Java语法，</span>
<span style="font-size: 20px">
比如多线程、注解等，以及其具体实现的精妙性、复杂性，<mark>很难保证该系列博客中记录的我个人的理解是正确无误的。</mark><br></span>
<span style="font-size: 20px">
&emsp;&emsp;此外，受限于个人对Java的理解水平有限，以及时间精力等多重因素的</span>
<span style="font-size: 20px">
限制，所以<mark>一些细节的部分无法做到面面俱到，只是对一些学习到的知识随手记录</mark>，</span>
<span style="font-size: 20px">
系统性和逻辑性都略有不足。可做抛砖引玉之用。<br></span>
</div>

<span id="more"></span>

<h2 id="二-系列博客的内容组成"><a href="#二-系列博客的内容组成" class="headerlink" title="二. 系列博客的内容组成"></a>二. 系列博客的内容组成</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在我的预想中，接下来这一系列博客将基本按以下的方式进行组织： <br></span>
<span style="font-size: 20px">
&emsp;&emsp;首先是命名，除了本章序章以外，基本按照第一章XX、第二章XX这样的方式</span>
<span style="font-size: 20px">
依次命名下去。其中XX是具体对此章内容的总体概括。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;然后是具体的各章内容，目前是这样计划的：<br>
&emsp;&emsp;(1)<br>&emsp;&emsp;&emsp;&emsp;首先是<a href="http://localhost:4000/2021/05/19/collection_0/">序章</a></span>
<span style="font-size: 20px">对系列博客的基本介绍以及为一些关键的说明作预留，以及一些可能<br></span>
<span style="font-size: 20px">&emsp;&emsp;有用的参考的资料的整理。<br>
&emsp;&emsp;(2)<br>&emsp;&emsp;&emsp;&emsp;然后是<a href="http://localhost:4000/2021/05/19/collection_1/">第一章</a></span>
<span style="font-size: 20px">，用来介绍Java迭代器接口Iterator和可迭代接口Iterable，他们对于<br></span>
<span style="font-size: 20px">&emsp;&emsp;后续集合的遍历非常有用，因此在第一章，我们尽可能将</span>
<span style="font-size: 20px">其常见的使用方法一网打尽。<br>
&emsp;&emsp;(3)<br>&emsp;&emsp;&emsp;&emsp;然后是第三章，正式进入对集合的整理，在这一章我们将</span>
<span style="font-size: 20px">对Collection接口中的所<br>
&emsp;&emsp;有抽象方法做详细理解，并通过其各种实现类进行相应的测试。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;(4)<br>&emsp;&emsp;&emsp;&emsp;然后是第三、四、五章，在这几章我们将</span>
<span style="font-size: 20px">对Collection接口的常见实现类中的中的<br>
&emsp;&emsp;常用方法做详细理解，并进行相应的测试，也会涉及到相当一些源码的阅读分析。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;(5)<br>&emsp;&emsp;&emsp;&emsp;To Be Continued!<br></span>
</div>

<h2 id="三-参考资料汇总"><a href="#三-参考资料汇总" class="headerlink" title="三. 参考资料汇总"></a>三. 参考资料汇总</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;<a href="https://docs.oracle.com/javase/8/docs/api/">Java JDK8官方API英文版</a><br>
&emsp;&emsp;<a href="https://www.matools.com/api/java8">Java JDK8官方API中文版</a></span>
<span style="font-size: 20px"><mark>(注意，机翻质量极低，不建议大量使用)</mark><br>
&emsp;&emsp;<a href="https://blog.csdn.net/u011240877/category_6447444.html">
一系列关于Java集合框架的原理分析博客</a>&emsp;&emsp;作者：拭心<br></span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;<br></span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;<br></span>
</div>



]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown学习笔记</title>
    <url>/2021/05/08/markdown/</url>
    <content><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a><center>Markdown学习笔记</center></h1><h2 id="一-markdown的简要介绍"><a href="#一-markdown的简要介绍" class="headerlink" title="一. markdown的简要介绍"></a>一. markdown的简要介绍</h2><p>
&emsp;&emsp;根据<a href="http://markdown.p2hp.com/getting-started/">
Markdown中文网 </a>的描述：Markdown是一种轻量级的标记语言，
可用于将格式设置元素添加到纯文本文档中。 
Markdown由John Gruber于2004年创建，如今已成为世界上最受欢迎的标记语言之一。<br>  
&emsp;&emsp;本学期软件构造课和计算机系统课都有大量的实验任务, 
在完成实验后，写一写博客,留下一些记录，既能够帮助自己整理所学所感，
也能给后来者提供一些微不足道的教程和帮助。<br>
&emsp;&emsp;这是我第一次认真尝试写一篇博客，才疏学浅，希望能够起到抛砖引玉的作用。
此外，本文中由于hexo配置与markdown本身语法以及使用编辑器的种种桎梏，有些本应有效
的markdown语法在实际呈现到blog的时候出现了与预期不符的问题，<mark>所以为了解决这些
问题，我被迫使用了一些html语言</mark>，但是实际上我并没有系统学习过markdown或者是html，
所以很有可能写的不规范或者不具有可扩展性和可移植性。<br>
&emsp;&emsp;同时为了排版方便以及演示代码的展现，大部分博客文字内容都呈现在代码块。<br>
&emsp;&emsp;下面正式进入正文部分：
</p>

<span id="more"></span>

<h2 id="二-markdown语法之标题"><a href="#二-markdown语法之标题" class="headerlink" title="二. markdown语法之标题"></a>二. markdown语法之标题</h2><p>
&emsp;&emsp;依据<a href="http://markdown.p2hp.com/basic-syntax/">
官方文档 </a>，markdown一共支持从大到小共六级标题，其具体使用语法如下所示：<br>
</p>

<pre><code>    在markdown中可以使用&quot;k个#+空格+HeaderName&quot;就可以生成一个k级标题，
k为1到6的整数。
    注意，使用这种方式创建标题时必须与上面的段落之间空一行
    而在html中可以使用&lt;hk&gt;HeaderName&lt;/hk&gt;的方法生成相应级别的标题。
    标题的字体大小与级数有关，1级标题的字体最大，6级标题的字体最小。
    此外，还有一种生成1、2级标题的替代格式，此处不再赘述。
    为了不破坏本博客的标题结构，此处就不做演示了。
</code></pre>
<h2> 三. markdown语法之文字处理</h2>

<h4 id="1-换行"><a href="#1-换行" class="headerlink" title="1. 换行"></a>1. 换行</h4><pre><code>    在markdown中可以使用两个空格加enter键换行,但不知是hexo的配置原因
还是我用IDEA/Typro编写md文件的时候直接按enter就会自动换行，这样其实还
挺麻烦的，因为没有办法在一段较长的时候分割开段落，因为一按回车就会自动强
行换行。这也是为什么我要在代码里引入html的原因。
    在html中，换行只需要在上一行尾部加上&lt;\br&gt;即可。
    如果不显示地用上述方法换行的话，直接按enter并不会在显示的时候换行，
只是可以在编写的时候重新提行写，这样更人性化。
    下面使用&quot;&amp;emsp;&amp;emsp;&amp;emsp;这是第一行&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;
这是第二行&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;这是第一行<br>&emsp;&emsp;&emsp;这是第二行</p>
<h3 id="2-粗体和斜体"><a href="#2-粗体和斜体" class="headerlink" title="2. 粗体和斜体"></a>2. 粗体和斜体</h3><pre><code>    (1)
        在markdown中对某个字或者某段词句加粗的语法为：**想要加粗的文字**
    或者在html中用&lt;strong&gt;想要加粗的文字&lt;/strong&gt;的方式加粗。
    (2)
        在markdown中对某个字或者某段词句设为斜体的语法为：*想要倾斜的文字*
    或者在html中用&lt;em&gt;想要加粗的文字&lt;/em&gt;的方式加粗。
    (3)
        如果既想要加粗又想要斜体，可以这样写：***想要加粗并倾斜的文字***
    或者在html中用&lt;strong&gt;&lt;em&gt;想要加粗的文字&lt;/em&gt;&lt;/strong&gt;。
    
        下面使用&quot;&lt;strong&gt;&lt;em&gt;markdown使用笔记&lt;/em&gt;&lt;/strong&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<strong><em>markdown使用笔记</em></strong></p>
<h3 id="3-居中"><a href="#3-居中" class="headerlink" title="3. 居中"></a>3. 居中</h3><pre><code>    我不清楚markdown是否提供了将文字居中的语法，所以我学习了如何使用html
来将文字居中，其具体语法为：&lt;center&gt;想要居中的文字&lt;/center&gt;
    下面使用&quot;&lt;center&gt;我在中间&lt;/center&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<center>我在中间</center></p>
<h3 id="4-上脚标和下脚标"><a href="#4-上脚标和下脚标" class="headerlink" title="4. 上脚标和下脚标"></a>4. 上脚标和下脚标</h3><pre><code>    在typro中偏好设置里可以选择引入markdown扩展语法中的脚标：
    ^上脚标^和~下脚标~
    但是我使用了上述方式成功在编辑器里测试了上下脚标功能后运用
到博客并部署到hexo中时却发现实际显示的结果与本机上测试有所不同。
所以，被逼无奈，又只好寻求html这个法宝了：
    在html中，添加上下脚标的语法为：
    &lt;sup&gt;上角标&lt;/sup&gt;和&lt;sub&gt;下脚标&lt;/sub&gt;
    不过有一个待解决的问题是如何打出双脚标，个人推可能需要Latex
插件的支持用公式编辑的方法打出来吧。
    下面使用&quot;H&lt;sub&gt;2&lt;/sub&gt;O&quot;和2&quot;&lt;sup&gt;10&lt;/sup&gt;=1024&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;H<sub>2</sub>O &emsp; 2<sup>10</sup>=1024<br></p>
<h3 id="5-高亮"><a href="#5-高亮" class="headerlink" title="5. 高亮"></a>5. 高亮</h3><pre><code>    在typro中偏好设置里可以选择引入markdown扩展语法中的高亮：
    ==想要高亮的文字==
    但是我使用了上述方式成功在编辑器里测试了上下脚标功能后运用
到博客并部署到hexo中时却发现实际显示的结果与本机上测试有所不同。
所以，被逼无奈，又只好寻求html这个法宝了：
    在html中，添加上下脚标的语法为：&lt;mark&gt;想要高亮的语句&lt;/mark&gt;
    下面使用&quot;&lt;mark&gt;注意了注意了&lt;/mark&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<mark>注意了注意了</mark></p>
<h3 id="6-下划线和删除线"><a href="#6-下划线和删除线" class="headerlink" title="6. 下划线和删除线"></a>6. 下划线和删除线</h3><pre><code>    markdown语法中，删除线的实现方法为:~~想要画上删除线的内容~~ ；
    下划线的实现方法未知，html中可以这样写：&lt;u&gt;想要画上下划线的内容&lt;/u&gt;
    下面使用&quot;~~请无视这句话~~&quot;以及&quot;&lt;u&gt;划重点啦&lt;/u&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<del>请无视这句话</del> &emsp; <u>划重点啦</u></p>
<h3 id="6-空格"><a href="#6-空格" class="headerlink" title="6. 空格"></a>6. 空格</h3><pre><code>    一种打空格的方式是直接按space键或者tab键，但是为了更好地控制空白
的大小，可以使用html当中的空格：
    可以用&quot;&amp;nbsp;&quot;或者&quot;&amp;ensp;&quot;或者&quot;&amp;emsp&quot;等不同定义的空格来实现想
要的空白宽度，具体可以参照这篇博客：html空格的五种表示(https://www.
cnblogs.com/SimonHu1993/p/9257176.html)。
    下面使用&quot;|&amp;nbsp|---------|&amp;ensp|---------|&amp;emsp;|&quot;来演示这
三种空格的大小：
</code></pre>
<p>&emsp;&emsp;&emsp;|&nbsp;|———|&ensp;|———|&emsp;|</p>
<h2 id="四-markdown语法之链接与引用"><a href="#四-markdown语法之链接与引用" class="headerlink" title="四. markdown语法之链接与引用"></a>四. markdown语法之链接与引用</h2><h4 id="1-自动链接"><a href="#1-自动链接" class="headerlink" title="1. 自动链接"></a>1. 自动链接</h4><pre><code>    自动链接就是将地址原封不动的显示出来，同时它也将生成该地址的超链接，
它常用于邮箱地址和较短网址的显示。语法是在该链接地址前后加上一对&lt; &gt;，常
用于显示邮箱或者网址等等。
    比如，使用代码&quot;&lt;https://github.com/&gt;&quot;可以生成如下的自动链接：
</code></pre>
<p>&emsp;&emsp;&emsp;<a href="https://github.com/">https://github.com/</a></p>
<h4 id="2-文本链接"><a href="#2-文本链接" class="headerlink" title="2. 文本链接"></a>2. 文本链接</h4><pre><code>    markdown支持行内式(inline)和参考式(reference)两种形式的超文本链
接语法格式。不管是哪一种，链接文字都是用方括号&quot;[]&quot;来标记。
    首先是行内式，其markdown语法为&quot;[txt](url)&quot;，对应html语法为&lt;a hr
ef=&quot;url&quot;&gt;text&lt;/a&gt;。如果你还想要加上链接的title，只要在网址后面用双引
号把title文字包起来即可。
    然后是参考式，其用途主要是可以先声明超链接但是并不给出其定义，而是在
md文件的任何其他位置(一般是末尾)加以定义。其markdown语法为：先定义参考
refid：[text][refid]，再定义参考refid所指向的具体地址[refid]:url。
注意，这里有一些简写和细节问题，详情可以参考下述用于演示参考式的链接里的
博客。
    以下我们用html语法&lt;a href=&quot;https://starlooo.github.io/&quot;&gt;我的
博客主页&lt;/a&gt;来演示行内式文编链接；然后用markdown语法[一篇关于链接的参
考博客][ref_blog_1]和[ref_blog_1]:https://blog.csdn.net/baox
iao7872/article/details/90240402来演示参考式文本链接：
</code></pre>
<p>&emsp;&emsp;&emsp;<a href="https://starlooo.github.io/">我的博客主页</a><br><br>&emsp;&emsp;&emsp;<a href="https://blog.csdn.net/baoxiao7872/article/details/90240402">一篇关于链接的参考博客</a></p>
<h4 id="3-图片链接"><a href="#3-图片链接" class="headerlink" title="3. 图片链接"></a>3. 图片链接</h4><pre><code>    markdown使用与文本链接几乎相同的方式来实现图片链接，同样支持行内式
和参考式两种形式，只是需要在方括号前加上一个&quot;!&quot;。
    以行内式为例，图片链接的markdown语法为：![alt_txt](url)，对应ht
ml写法为&lt;img src=&quot;url&quot; alt=&quot;text&quot;&gt;，其中文本部分可选，如果没有需要可
以不写。
    但这里有个问题，我目前虽然可以把本地的图片链接入markdown，但当写博
客部署到云端后却发现图片无法加载。目前的解决方法是使用图床，将自己本地的
图片上传到网上，然后生成链接来引用。下面提供的链接的知乎回答里有关于一些
图床的介绍，读者可以自行选用。
    以下我们分别用markdown语法：[illustration_1](https://z3.ax1x
.com/2021/05/08/gGdtld.jpg)]和html语法&lt;img src=&quot;https://z3.ax1
x.com/2021/05/09/gYI9n1.jpg&quot; alt=&quot;gYI9n1.jpg&quot; border=&quot;0&quot; /&gt;来
演示图片链接：
</code></pre>
<p><img src="https://z3.ax1x.com/2021/05/08/gGdtld.jpg" alt="illustration_1"><br><img src="https://z3.ax1x.com/2021/05/09/gYI9n1.jpg" alt="illustrtion_2"></p>
<h4 id="4-块引用"><a href="#4-块引用" class="headerlink" title="4. 块引用"></a>4. 块引用</h4><pre><code>    markdown可以创建块引用，具体方法是在段落前添加一个&quot;&gt;&quot;，如果需要对
多个段落添加块引用需要在空行前也加上&quot;&gt;&quot;。
    同时，块引用可以嵌套使用，可以在一级块引用内使用&quot;&gt;&gt;&quot;创建二级块引用。
另一方面块引用的内部也可以使用markdown的其他语法元素，具体可以自行尝试。
    以下我们用&gt;**块引用段落1**&lt;br&gt;和&gt;*块引用段落2*&lt;br&gt;以及&gt;&gt;&lt;mark&gt;
嵌套块引用&lt;mark&gt;引用来演示块引用：
</code></pre>
<blockquote>
<p><strong>块引用段落1</strong><br><br><em>块引用段落2</em><br></p>
<blockquote>
<p><mark>嵌套块引用<mark></p>
</blockquote>
</blockquote>
<h4 id="5-代码和代码块"><a href="#5-代码和代码块" class="headerlink" title="5. 代码和代码块"></a>5. 代码和代码块</h4><pre><code>    markdown中可以标记行内代码，具体方法是使用一对反引号&quot;`&quot;将想要写的代码
框住，或者使用html语法中的&lt;code&gt;inline_code&lt;code&gt;。
    此外，markdown可以创建代码块，具体方法是在段代码块的每一行前缩进4个空
格或者1个制表符。另以种方式是把代码块框在一对“```”或者&quot;~~~&quot;之内。另外，根
据我的实验，使用4个空格或1个制表符的方式与使用3个反引号或波浪号框住的方式的
区别在于后者创建的代码块会标上行号。
    以下我们用&quot;`printf()`函数是C语言的基本输出函数&quot;和一段写有HelloMarkd
own程序的代码块来演示：
</code></pre>
<p><code>printf()</code>函数是C语言的基本输出函数<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Hello, markdown!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-markdown语法之列表与表格"><a href="#五-markdown语法之列表与表格" class="headerlink" title="五. markdown语法之列表与表格"></a>五. markdown语法之列表与表格</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1. 无序列表"></a>1. 无序列表</h3><pre><code>    可以使用在行首加上&quot;-&quot;或&quot;+&quot;或&quot;*&quot;标记的方式创建markdown无序列表。所谓
无序列表，指的是各表项间是并列关系，并没有相对先后顺序。渲染结果是一个小圈。
    此外可以在无序列表内部用同样的方式创建嵌套的无序列表。
    以下代码用来演示无序列表的创建:
    * 无序列表的演示,表项1
        - 无序列表的演示，子表项1
        + 无序列表的演示，子表项2

    * 无序列表的演示,表项2
</code></pre>
<ul>
<li>无序列表的演示,表项1<ul>
<li>无序列表的演示，子表项1</li>
</ul>
<ul>
<li>无序列表的演示，子表项2</li>
</ul>
</li>
<li>无序列表的演示,表项2        </li>
</ul>
<h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2. 有序列表"></a>2. 有序列表</h3><pre><code>    可以使用在行首加上”x.“标记的方式创建markdown有序列表，其中x为相应数字。
所谓有序列表，指的是各表项间是递进关系，有相对先后顺序。渲染结果是一个从1开始
按顺序拍下去的各表项，而子表项用排序渲染出的是对应罗马数字。
    此外可以在有序列表用相同的方式创建嵌套的有序列表，甚至可以用创建无序列表
的方式嵌套无序列表，反之亦然。
    以下代码用来演示有序列表的创建:
    1. 有序列表的演示,表项1
        1. 有序列表的演示，子表项1
        2. 有序列表的演示，子表项2

    2. 有序列表的演示,表项2
</code></pre>
<ol>
<li><p>有序列表的演示,表项1</p>
<ol>
<li>有序列表的演示，子表项1</li>
<li>有序列表的演示，子表项2</li>
</ol>
</li>
<li><p>有序列表的演示,表项2</p>
</li>
</ol>
<h3 id="3-表格"><a href="#3-表格" class="headerlink" title="3. 表格"></a>3. 表格</h3><pre><code>    markdown支持使用&quot;|&quot;分割各表格项以及标记表格的行首行尾的方式创建表格，其中
行首行尾的&quot;|&quot;可以省略。第一行一般用于写每列的列名，列名采取居中对齐方式。
    在对齐方面，可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，可以在
相应位置写入&quot;-:&quot;表示这列的文字采用右对齐，同理&quot;:-&quot;表示左对齐，&quot;:-:&quot;表示居中对
齐。此外，需要注意创建表格时需要与上一段有一个空行，不然无法被识别。
    不知道是什么原因，在我使用IDEA编写md文件时，第二行里如果只使用一个&quot;-&quot;的话
实时渲染的结果并没有创建出对应表格，但实际上部署到云端博客的时候是创建了相应表格
的。但为了本地测试方便，我还是写了3个以上的&quot;-&quot;让IDEA识别出表格。
    以下代码用来演示创建表格：
    | 左对齐列 | 右对齐列 | 居中对齐列 |
    | :------| ------: | :------: |
    | 短文本 | 中等文本 | 稍微长一点的文本 |
    | 稍微长一点的文本 | 短文本 | 中等文本 |
</code></pre>
<table>
<thead>
<tr>
<th align="left">左对齐列</th>
<th align="right">右对齐列</th>
<th align="center">居中对齐列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">短文本</td>
<td align="right">中等文本</td>
<td align="center">稍微长一点的文本</td>
</tr>
<tr>
<td align="left">稍微长一点的文本</td>
<td align="right">短文本</td>
<td align="center">中等文本</td>
</tr>
</tbody></table>
<p>以下是两篇有关于markdown表格的参考博客:</p>
<p><a href="https://www.jianshu.com/p/2df05f279331">Markdown插入表格语法</a></p>
<p><a href="https://blog.csdn.net/tuxingchen6/article/details/55222951">利用Markdown创建表格</a></p>
]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>测试</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类学习笔记第一章--迭代器</title>
    <url>/2021/05/21/collection_1/</url>
    <content><![CDATA[<h1 id="Java集合类学习笔记第一章–迭代器"><a href="#Java集合类学习笔记第一章–迭代器" class="headerlink" title="Java集合类学习笔记第一章–迭代器"></a><center>Java集合类学习笔记第一章–迭代器</center></h1><h2 id="一-本章概述"><a href="#一-本章概述" class="headerlink" title="一. 本章概述"></a>一. 本章概述</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在本章中，主要介绍Java迭代器的有关内容。<br>
&emsp;&emsp;要讲集合，首先得讲清楚迭代器。在JDK中可以从接口声明中清楚的看到<a href="https://doc
s.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>接口继承自</span>
<span style="font-size: 20px">
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterable.html">Iterable</a>接口。<br>
&emsp;&emsp;而迭代器<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">
Iterator</a>接口</span>
<span style="font-size: 20px">,具体到其在各种集合类中对应的实现，为我们提供了有效地访问、遍历不同类型的集合中元素的方法。<br>
&emsp;&emsp;因此，我把对Iterable和Iterator这两个接口的学习放到了第一章。本章的学习目的为：</span>
<span style="font-size: 20px">
基本掌握Java迭代器在集合类当中的使用，同时对迭代器使用过程中的有关注意事项有一个清楚的认知。<br></span></div>

<span id="more"></span>

<h2 id="二-迭代器接口和可迭代接口的基本介绍"><a href="#二-迭代器接口和可迭代接口的基本介绍" class="headerlink" title="二. 迭代器接口和可迭代接口的基本介绍"></a>二. 迭代器接口和可迭代接口的基本介绍</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;根据官方API中对Iterable可迭代接口的说明:"Implementing this interface allows an object to be the target </span>
<span style="font-size: 20px">of the "for-each loop" statement."，实现了Iterable接口的对象就可以使用for-each循环。那么，</span>
<span style="font-size: 20px">什么是for-each循环呢?<br>
&emsp;&emsp;for-each循环，又称增强for循环，是JDK5的新特性中定义的一种新的循环语法，语法的标准格式为：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for( 数据类型 变量名 : 遍历的目标对象 ) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;最常见的比如数组就支持for-each循环，以下是用普通for循环和增强for循环对数组遍历的示例程序：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void loopTest() &#123;</span><br><span class="line">    int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">    System.out.println(&quot;普通for循环:&quot;);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;\n增强for循环:&quot;);</span><br><span class="line">    for(int num : arr) &#123;</span><br><span class="line">        System.out.print(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="font-size: 20px">&emsp;&emsp;执行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/20/gIgQP0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;根据官方API，Iterable接口中的定义为：<code>public Interface Iterable&lt;T&gt;</code>，内部的抽象方法只有一个:</span>
<span style="font-size: 20px"><code>Iterator&lt;T&gt;iterator()</code></span>
<span style="font-size: 20px">其作用为返回一个元素类型为T的迭代器。所有实现了Iterable的接口都实现了这个方法，特别的，集合也是。<br>
&emsp;&emsp;接着我们看看Iterator接口的API，接口定义为：<code>public Interface Iterator<&#917;></code>。官方文档对其有如下的解释：
<br>&emsp;&emsp;Iterator是用来替代原来集合框架中的<a href="">Enumeration</a>接口的，</span>
<span style="font-size: 20px">其相比Enumeration接口，有以下两个变化：其一是迭代器允许调用者在迭代过程中使用定义明确的语义</span>
<span style="font-size: 20px">从集合中删除元素；其二是对方法的命名有所改进。第一点中所谓定义明确的语义，听起来有点费解</span>
<span style="font-size: 20px">我们会在接下来的小节研究这一部分的内容，这里就先跳过了。<br>
&emsp;&emsp;Iterator中声明了两个抽象方法和两个默认方法，其中最重要也是最常用的三个方法分别为：<br>
&emsp;&emsp;<code>boolean hasNext()</code> ，作用为判断迭代是否还有下一个元素。换句话说，当该方法返回true时，调用next方法</span>
<span style="font-size: 20px">会返回下一个元素而不是抛出异常<br>
&emsp;&emsp;<code>E    next()</code> ，作用为返回迭代的下一个元素，如果迭代已经没有下一个元素了，则会抛出NoSuchElementException。<br>
&emsp;&emsp;<code>default void remove()</code> ，作用为从集合中移除此迭代器最近返回的那个元素。</span>
<span style="font-size: 20px">关于该默认方法有一些注意事项，我们会在第三小节中详细说明。<br></span>
</div>


<h2 id="三-Iterator接口的详细介绍"><a href="#三-Iterator接口的详细介绍" class="headerlink" title="三. Iterator接口的详细介绍"></a>三. Iterator接口的详细介绍</h2><div style="font-size: 20px">
&emsp;&emsp;下面仔细研究一下Iterator接口中的这三个方法，使用集合类中大家最熟悉的ArrayList做测试。<br></div>

<h3 id="part1–hasNext方法"><a href="#part1–hasNext方法" class="headerlink" title="part1–hasNext方法"></a>part1–hasNext方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns true if the iteration has more elements.</mark></span>
<span style="font-size: 20px"><mark>(In other words, returns true if next() would return an element
rather than throwing an exception.)</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void hasNextTest() &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">        Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        arraylist.add(1);</span><br><span class="line">        &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">        it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;空迭代器调用hasNext方法会抛出NullPointerException</span><br><span class="line">        ArrayList&lt;Integer&gt; null_arr &#x3D; null;</span><br><span class="line">        Iterator&lt;Integer&gt; null_it &#x3D; null_arr.iterator();</span><br><span class="line">        System.out.println(null_it.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZYnA.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，第一次获取arraylist的迭代器的时候，arraylist为空，所以it.hasNext输出为false; 而第二次获取arraylist</span>
<span style="font-size: 20px">迭代器的时候，arraylist中有一个元素1，所以it.hasNext输出为true; 接着我们定义了一个空的ArrayList对象，</span>
<span style="font-size: 20px">获得了它的迭代器，此时这个迭代器为空，若对空迭代器调用hasNext方法，则会产生NullPointerException异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part2–next方法"><a href="#part2–next方法" class="headerlink" title="part2–next方法"></a>part2–next方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns the next element in the iteration.</mark></span>
<span style="font-size: 20px"><mark>Throws NoSuchElementException if the iteration has no more elements.</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void nextTest() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line"></span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果it.hasNext()为false的时候调用it.next会产生NoSuchElementException</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZIc4.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在while循环的循环判断中，我们使用it.hasNext()来判断迭代是否有下一个元素，当迭代有下个元素的时候，</span>
<span style="font-size: 20px">我们再调用it.next()，此时可以保证it.next()返回的是下一个元素而不会抛出异常。</span>
<span style="font-size: 20px"><mark>这也是一种标准的非常建议的迭代器的使用方法</mark>，我们会在第四节中再提及这一点。<br>
&emsp;&emsp;根据打印结果，说明每次调用next()方法，在得到下一个元素的同时，迭代器的位置都会发生移动，使得下一次调用next()方法的时候</span>
<span style="font-size: 20px">迭代的下一个元素(如果有的话)是当前next()返回元素的下一个。具体到示例程序中，就是依次返回1、2、3。<br>
&emsp;&emsp;接着，程序退出while循环，说明hasNext()返回值为false，此时迭代到了末尾，已经没有下一个元素了，如果此时调用next()方法</span>
<span style="font-size: 20px">就会像API中规定的那样，抛出NoSuchElement异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part3–remove方法"><a href="#part3–remove方法" class="headerlink" title="part3–remove方法"></a>part3–remove方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Removes from the underlying collection
the last element returned by this iterator (optional operation). This method can be called only
once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified 
while the iteration is in progress in any way other than by calling this method.</mark></span>
<span style="font-size: 20px"><mark>Throws:UnsupportedOperationException if the remove operation
is not supported by this iterator. Throws IllegalStateException if the next method has not yet 
been called, or the remove method has already been called after the last call to the next method.</mark><br>
&emsp;&emsp;这个说明文档非常长，里面涉及的值得注意的地方也很多，其中最关键的便是以下四点：<br>
&emsp;&emsp;(1) remove()删除的是该迭代器最近返回的元素，即上一次调用next()返回的那一个元素。<br>
&emsp;&emsp;(2) 每次调用next()后，至多调用一次remove()，否则会抛出IllegalStateException异常。<br>
&emsp;&emsp;(3) 不能未经调用next()就直接调用remove()，否则也会抛出IllegalStateException异常。<br>
&emsp;&emsp;(4) 如果在迭代正在进行中以除调用该remove()方法之外的任何方式修改这个集合，则迭代器的行为未定义。<br>
&emsp;&emsp;我们来研究测试一下第(4)，这有助于我们理解为什么在很多集合类比如ArrayList本身拥有remove()方法的前提下，JDK</span>
<span style="font-size: 20px">在Iterator中还要提供迭代器专有的remove()方法：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void removeTest1() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中不删除元素</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中正确使用Iterator专有的remove()方法删除元素</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(&quot;当前迭代元素：&quot; + it.next());</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;***************************************&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此时arraylist中的所有元素都在迭代的过程中被迭代器的remove()方法正确删除了</span><br><span class="line">    System.out.println(arraylist.size());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;***************************************&quot;);</span><br><span class="line"></span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line">    &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中错误使用ArrayList类中的remove()方法删除元素，注意，这是绝对不建议的行为</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        Integer ele &#x3D; it.next();</span><br><span class="line">        System.out.println(&quot;当前迭代元素：&quot; + ele);</span><br><span class="line">        &#x2F;&#x2F;能删除成功，但是删除成功后迭代器将产生API中未定义的行为</span><br><span class="line">        System.out.println(arraylist.remove(ele));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g71enU.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，示例程序在第一部分展现的是正常的迭代并输出，在迭代的过程中我们没有使用任何的删除方法。第二部分中，在while循环里</span>
<span style="font-size: 20px">每调用一次next()方法后，我们调用一次Iterator专有的remove()方法删除集合中的元素，最后迭代结束后打印</span>
<span style="font-size: 20px">arraylist的元素个数，发现是0。并且整个迭代过程中并没有抛出任何异常，说明我们的使用是正确的。实际上，</span>
<span style="font-size: 20px"><mark>这是我们极其建议的API中规定的使用方法</mark>。<br>
&emsp;&emsp;反之，在第三部分中，我们尝试进行跟第二部分几乎一样的过程，唯一的不同在于删除元素的时候，我们尝试使用ArrayList中</span>
<span style="font-size: 20px">的remove方法而不是迭代器的remove方法。<mark>这是我们极不建议的方法</mark>，</span>
<span style="font-size: 20px">事实上，这回导致(4)中的严重问题。执行结果表明在第一次删除元素1之后，再次进入循环后，调用</span>
<span style="font-size: 20px">迭代器next方法时发生了错误，抛出了ConcurrentModificationException异常。</span>
<span style="font-size: 20px">应当是错误的删除操作破坏了迭代器的结构，使得迭代器无法按照其具体实现的代码逻辑正常执行功能。<br>
&emsp;&emsp;<mark>所以在使用迭代器迭代的过程中，务必遵照API的要求，只能使用迭代器中提供的方法修改集合的元素。</mark><br>
&emsp;&emsp;接下来我们来看看(2)和(3)的测试：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void removeTest2() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;测试调用1次next()后调用2次remove(),会抛出IllegalStateException异常</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    it.remove();</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void removeTest3() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;测试未调用next()直接调用remove(),也会抛出IllegalStateException异常</span><br><span class="line">    it.remove();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果分别如下：<br></span><br><span style="font-size: 20px">&emsp;&emsp;removeTest2()：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7Gf4H.png" alt="illustration_1"><br><br><br><span style="font-size: 20px">&emsp;&emsp;removeTest3()：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7G58A.png" alt="illustration_2"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，示例程序removeTest2在调用1次next()后调用2次remove(),会按(2)中所说的那样，</span>
<span style="font-size: 20px">抛出IllegalStateException异常。而示例程序removeTest3在未调用next()时直接调用</span>
<span style="font-size: 20px">remove()方法,会按(3)中所说的那样，也会抛出一个IllegalStateException异常。<br>
&emsp;&emsp;因此，在使用迭代器的remove的方法时，一定要确保调用remove()前要先调用next(),并且每调用一次next()，</span>
<span style="font-size: 20px">最多只能调用一次remove()。<br>
&emsp;&emsp;举个形式化的例子，设n的初始值为0，在集合元素足够多的情况下，每调用一次next()使n的值置为1，而每调用一次remove()使n减小1，</span>
<span style="font-size: 20px">一个合法的调用序列需要满足任意时刻n的值非负。<br>
&emsp;&emsp;比如next()->next()->remove()->next()->remove()->next()就是一个合法的调用序列，对应n的变化为：</span>
<span style="font-size: 20px">0->1->1->0->1->0->1。而next()->next()->remove()->next()->remove()->remove()</span>
<span style="font-size: 20px">就是一个非法的调用序列对应n的变化为：</span>
<span style="font-size: 20px">0->1->1->0->1->0->-1(非法)。<br></span></div>

<h2 id="四-for循环、for-each循环与迭代器"><a href="#四-for循环、for-each循环与迭代器" class="headerlink" title="四. for循环、for-each循环与迭代器"></a>四. for循环、for-each循环与迭代器</h2><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;到目前未知，我们一共有三种备选的方法可以用于对集合对象进行循环遍历，分别为：for循环、for-each循环(enhanced-for循环)</span>
<span style="font-size: 20px">与使用对应的迭代器迭代。我们首先各自分析它们的特点，然后进行对比分析，尝试得出对比的结论。<br></span></div>

<h3 id="part1–for循环"><a href="#part1–for循环" class="headerlink" title="part1–for循环"></a>part1–for循环</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;for循环十分简单，我们经常在数组循环的时候使用这种方法，以下是一段非常常见的for循环代码：<br>
</span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void forloopTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            Integer now &#x3D; arraylist.get(i); &#x2F;&#x2F;顺序结构的arraylist的for循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            Integer now &#x3D; linkedlist.get(i); &#x2F;&#x2F;链式结构的linklist的for循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;for循环示例程序中的内层for循环的平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7XVkn.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在该for循环示例程序中我们先通过一系列手段声明并初始化两个长度10000的List,其中一个是顺序结构的arraylisr，</span>
<span style="font-size: 20px">另一个是链式结构的linkedlist。接着进行100次相同的循环，每次外循环里都嵌套两个内循环，内循环里分别依次获得这</span>
<span style="font-size: 20px">两个List各自对应下标的元素。最后分别打印出两种结构这100次内层for循环的平均执行时间。</span>
<span style="font-size: 20px">结果为：<mark>顺序结构为0.01ms，链式结构为33.65ms</mark>,这个数据在接下来我们做对比的时候还会用到。<br>
</span></div>

<h3 id="part2–for-each循环"><a href="#part2–for-each循环" class="headerlink" title="part2–for-each循环"></a>part2–for-each循环</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;IDEA有时会提醒你可以for-each循环替代某些for循环，这应当是有其内在原因的，以下是一段与part1中对应代码逻辑一致代码</span>
<span style="font-size: 20px">只不过内层循环的实现采用了for-each循环：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void forEachloopTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(Integer ele : arraylist) &#123;</span><br><span class="line">            Integer now &#x3D; ele; &#x2F;&#x2F;顺序结构的arraylist的forEach循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(Integer ele : linkedlist) &#123;</span><br><span class="line">            Integer now &#x3D; ele; &#x2F;&#x2F;链式结构的linklist的forEach循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;forEach循环示例程序中的内层forEach循环的平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7vTS0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，该forEach循环示例程序与for循环示例程序基本一样，只不过循环的方式改成了for-each循环</span>
<span style="font-size: 20px">最后分别打印出两种结构这100次内层for循环的平均执行时间。结果为：</span>
<span style="font-size: 20px"><mark>顺序结构为0.18ms，链式结构为0.08ms</mark>,这个数据在接下来我们做对比的时候还会用到。<br></span></div>

<h3 id="part3–迭代器"><a href="#part3–迭代器" class="headerlink" title="part3–迭代器"></a>part3–迭代器</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;而我们之前讲的迭代器呢？它与for循环和forEach循环直接有什么关系，来看下面一段示例程序，</span>
<span style="font-size: 20px">同样，与par1和part2中的代码相比，par3中程序只是将原本的内层循环改为了迭代器迭代：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void iterationTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; arr_it &#x3D; arraylist.iterator();</span><br><span class="line">        Iterator&lt;Integer&gt; link_it &#x3D; linkedlist.iterator();</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        while(arr_it.hasNext()) &#123;</span><br><span class="line">            Integer now &#x3D; arr_it.next(); &#x2F;&#x2F;顺序结构的arraylist的迭代</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        while(link_it.hasNext()) &#123;</span><br><span class="line">            Integer now &#x3D; link_it.next();&#x2F;&#x2F;链式结构的linklist的迭代</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;迭代示例程序中的迭代平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7zorT.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，该迭代示例程序与for循环示例程序和for-each循环示例程序基本一样，只不过把循环改成了迭代</span>
<span style="font-size: 20px">最后分别打印出两种结构这100次内层for循环的平均执行时间。结果为：</span>
<span style="font-size: 20px"><mark>顺序结构为0.03ms，链式结构为0.1ms</mark>,这个数据在接下来我们做对比的时候还会用到。<br></span></div>

<h3 id="part4–对比分析"><a href="#part4–对比分析" class="headerlink" title="part4–对比分析"></a>part4–对比分析</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;首先根据我们在part1、part2、part3中的示例程序的运行结果，<mark>从效率上分析</mark>这三种方法的异同：<br>
&emsp;&emsp;<mark>对于顺序结构来说，不论是直接采用for循环，还是采用for-each循环或者迭代器来遍历，效率都是很高的。</mark></span>
<span style="font-size: 20px">原因在于：顺序结构实现的Array或者ArrayList都支持随即检索，按下标查找任何一个位置元素的效率都是常数，</span>
<span style="font-size: 20px">而与位置无关。<br>
&emsp;&emsp;<mark>而对于链式结构来说，采用迭代器或是for-each循环遍历的效率远远高于采用普通的for循环。</mark></span>
<span style="font-size: 20px">原因是普通for循环中调用的get方法，对于链式结构无法采用随机访问的方式寻址，只能通过顺序访问的方式找到对应位置</span>
<span style="font-size: 20px">的链表元素，效率与元素所在位置有关，并不是常数。而用for-each循环和迭代的时候，其内部的实现机制能够</span>
<span style="font-size: 20px">使得访问元素的效率为常数，因此效率很高。<br>
&emsp;&emsp;总而言之就是：</span><span style="font-size: 20px">
<mark>对于链式结构的集合，建议采用for-each循环和迭代器进行遍历；对于顺序结构的集合，几种方法在效率上无明显差距。</mark>此外，</span>
<span style="font-size: 20px">对于HashMap、HashSet等元素没有下标的集合，根本无法使用for循环进行遍历，就只能用后两种方法了。<br>
&emsp;&emsp;而关于迭代和for-each循环的异同，我们可以作如下总结：<br>
&emsp;&emsp;for-each本身的实现其实还是在内部使用的迭代器，只不过for-each循环的语法比迭代器简洁。</span><span style="font-size: 20px">
而迭代器的优势在于，<mark>如果需要在遍历的过程中修改、删除元素的话，就必须使用迭代器。</mark><br></span></div>



<h2 id="五-ListIterator简介"><a href="#五-ListIterator简介" class="headerlink" title="五. ListIterator简介"></a>五. ListIterator简介</h2><p><span style="font-size: 20px">&emsp;&emsp;To Be Continued!<br></span></p>
<h2 id="六-参考资料"><a href="#六-参考资料" class="headerlink" title="六. 参考资料"></a>六. 参考资料</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterable.html">Java JDK8官方API Iterable</a><br>
&emsp;&emsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">Java JDK8官方API Iterator</a><br>
&emsp;&emsp;<a href="https://docs.oracle.com/javase/8/docs/
api/java/util/ListIterator.html">Java JDK8官方API Iterator</a><br>
&emsp;&emsp;<a href="https://blog.csdn.net/u011240877/article/
details/52743564">Java 集合源码解析(1)：Iterator</a>&emsp;&emsp;作者：拭心<br>
&emsp;&emsp;<a href="https://shixin.blog.csdn.net/article/
details/52752589">Java 集合源码解析(2)：ListIterator</a>&emsp;&emsp;作者：拭心<br>
&emsp;&emsp;<a href="https://blog.csdn.net/Jae_Wang/
article/details/80526216">Java迭代器(iterator详解以及和for循环的区别)</a>&emsp;&emsp;作者：Jae_Wang<br>
&emsp;&emsp;<a href="https://blog.csdn.net/import_sadaharu/
article/details/78906160">List逆向遍历、反向遍历--Iterator详解</a>&emsp;&emsp;作者：萨达哈鲁君<br>
&emsp;&emsp;<a href="https://zhuanlan.zhihu.com/p/193139479">聊聊Java中的迭代器</a>&emsp;&emsp;作者：helloworld2017<br></span>
</div>

]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>软件构造课程随笔--IDEA是如何帮你重写equals()方法的？</title>
    <url>/2021/06/19/equals/</url>
    <content><![CDATA[<h1 id="IDEA是如何帮你重写equals-方法的？"><a href="#IDEA是如何帮你重写equals-方法的？" class="headerlink" title="IDEA是如何帮你重写equals()方法的？"></a><center>IDEA是如何帮你重写equals()方法的？</center></h1><h2 id="一-写在前面"><a href="#一-写在前面" class="headerlink" title="一. 写在前面"></a>一. 写在前面</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在本软件构造课程的第8讲中，我们学习了如何判断两个对象的等价性，了解了什么是引用等价性(在Java中使用==符号判断)以及什么是</span>
<span style="font-size: 20px">
行为等价性(在Java中使用equals()方法来判断)。以及对于immutable的对象，我们应当重写其继承自Object类的equals()方法和hashCode()方法，
并且在其中实现观察等价性或者行为等价性(对immutable对象来说观察等价性就是行为等价性)；而对于mutable对象来说，最好是不对其</span>
<span style="font-size: 20px">
继承自Object类的equals()方法和hashCode()方法进行重写，就让它用默认的==来实现行为等价性。<br>
&emsp;&emsp;在平时写Java代码的时候，相信大多数同学跟我一样，因为不论使用的IDE是IDEA还是Eclipse，都提供了自动重写equals()和hashCode()方法</span>
<span style="font-size: 20px">
的快捷键，所以大家平时应该都不是自己手动重写equals()和hashCode()方法而是依靠IDE帮我们自动生成。这当然是不错的，毕竟</span>
<span style="font-size: 20px">
现代IDE的一大工作就是尽可能减少程序员的工作量。不过，在开心的使用IDE的代码自动生成功能之前，我们还是需要仔细了解其原理，不然不管是</span>
<span style="font-size: 20px">
期末考试还是以后面试，需要我们手写代码的时候，就露陷了。<br>
&emsp;&emsp;因此，<mark>本篇博客旨在向大家介绍IDE(以IDEA为例，Eclipse同理)是怎么帮我们重写equals()方法的</mark>。特别是考虑到</span>
<span style="font-size: 20px">
调查身边同学，问他们是否了解IDE是如何自动生成equals()方法的时候，大家都不是很了解，就更加坚定了我要写一篇这样的博客的决心。希望能对大家有所帮助。<br>
&emsp;&emsp;在进入正文之前，<mark>首先给出本文中用来进行测试的三个类的代码，他们分别是父类SuperClass、子类SubClassA和SubClassB</mark>，代码分别如下：
</span></div>

<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SuperClass类的代码</span><br><span class="line">public class SuperClass &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int elseSuperFields;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;superClass的构造器</span><br><span class="line">    public SuperClass(String name, int elseSuperFields) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.elseSuperFields &#x3D; elseSuperFields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SubClassA类的代码</span><br><span class="line">public class SubClassA extends SuperClass &#123;</span><br><span class="line">    &#x2F;&#x2F;extends String name from SuperClass</span><br><span class="line">    &#x2F;&#x2F;extends int elseSuperFields from SuperClass</span><br><span class="line">    int elseSubAFields;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;SubClassA的构造器</span><br><span class="line">    public SubClassA(String name, int elseSuperFields, int elseSubAFields) &#123;</span><br><span class="line">        super(name, elseSuperFields);</span><br><span class="line">        this.elseSubAFields &#x3D; elseSubAFields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;SubClassB类的代码</span><br><span class="line">public class SubClassB extends SuperClass &#123;</span><br><span class="line">    &#x2F;&#x2F;extends String name from SuperClass</span><br><span class="line">    &#x2F;&#x2F;extends int elseSuperFields from SuperClass</span><br><span class="line">    int elseSubBFields;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;SubClassB的构造器</span><br><span class="line">    public SubClassB(String name, int elseSuperFields, int elseSubBFields) &#123;</span><br><span class="line">        super(name, elseSuperFields);</span><br><span class="line">        this.elseSubBFields &#x3D; elseSubBFields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-instanceof关键字"><a href="#二-instanceof关键字" class="headerlink" title="二. instanceof关键字"></a>二. instanceof关键字</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在具体介绍IDE是如何自动生成equals()方法之前，首先需要介绍Java当中的一个运算符instanceof和一个方法getClass()方法，它们是IDE在实现</span>
<span style="font-size: 20px">
equals()方法时可能会用到的。<br>
&emsp;&emsp;首先是instanceof运算符，它的语法为：a instanceof ClassA，其中：a是一个对象而不能是基本数据类型，ClassA是一个类的类名。</span>
<span style="font-size: 20px">
当a是ClassA类的对象(包括a是ClassA的构造器构造出的对象，或者是ClassA的任何一个直接或者间接子类的对象，以及当ClassA是接口，a是该接口的实现类的对象等情况)</span>
<span style="font-size: 20px">
的时候该运算结果为true，否则为false。<br>
&emsp;&emsp;我们来测试一下，测试代码如下，测试结果已经以注释的形式写在了源代码中：</span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void instanceTest() &#123;</span><br><span class="line">    SuperClass super1 &#x3D; new SuperClass(&quot;NAME&quot;, 1);</span><br><span class="line">    SuperClass super2 &#x3D; new SubClassA(&quot;NAME&quot;, 1, 100);</span><br><span class="line">    SuperClass super3 &#x3D; new SubClassB(&quot;NAME&quot;, 1, 101);</span><br><span class="line"></span><br><span class="line">    SubClassA subA &#x3D; new SubClassA(&quot;NAME&quot;, 1, 102);</span><br><span class="line">    SubClassB subB &#x3D; new SubClassB(&quot;NAME&quot;, 1, 104);</span><br><span class="line"></span><br><span class="line">    System.out.println(super1 instanceof Object); &#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super1 instanceof SuperClass);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super1 instanceof SubClassA);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(super1 instanceof SubClassB);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(&quot;************************************&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(super2 instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super2 instanceof SuperClass);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super2 instanceof SubClassA);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super2 instanceof SubClassB);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(&quot;************************************&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(super3 instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super3 instanceof SuperClass);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(super3 instanceof SubClassA);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(super3 instanceof SubClassB);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(&quot;************************************&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(subA instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(subA instanceof SuperClass);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(subA instanceof SubClassA);&#x2F;&#x2F;true</span><br><span class="line">    &#x2F;&#x2F;System.out.println(subA instanceof SubClassB);  &#x2F;&#x2F;编译报错：Inconvertible types; cannot cast &#39;UsedClasses.SubClassA&#39; to &#39;UsedClasses.SubClassB&#39;</span><br><span class="line">    System.out.println(&quot;************************************&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(subB instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(subB instanceof SuperClass);&#x2F;&#x2F;true</span><br><span class="line">    &#x2F;&#x2F;System.out.println(subB instanceof SubClassA);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(subB instanceof SubClassB);  &#x2F;&#x2F;编译报错：Inconvertible types; cannot cast &#39;UsedClasses.SubClassB&#39; to &#39;UsedClasses.SubClassA&#39;</span><br><span class="line">    System.out.println(&quot;************************************&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(null instanceof Object);&#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;从上述测试结果中我们可以分析得到以下几点信息：<br>
&emsp;&emsp;①super1和super2、super3都是instanceof Object、也都是instanceof SuperClass，这是自然的，因为它们都是Object子类的对象，也都是SuperClass或者SuperClass子类的对象。<br>
&emsp;&emsp;②super1既不是instanceof SubClassA也不是instanceof SubClassB。注意到super1在定义的时候使用的是SuperClass的构造器，</span>
<span style="font-size: 20px">
也就是说其运行时类型为SuperClass，这说明<mark>运行时类型为父类的对象并不是instanceof 子类</mark>，这是合理的。<br>
&emsp;&emsp;③super2是instanceof SubClassA但不是instanceof SubClassB，super3反之。注意到super2在定义的时候使用的是SubClassA的构造器，</span>
<span style="font-size: 20px">
其运行时类型为SubClassA，所以super2 instanceof SubClassA == true。这再次说明<mark>instanceof在判断的时候使用的是运行时类型</mark>。<br>
&emsp;&emsp;④subA是instanceof Object，是instanceof SuperClass也是instanceof SubClassA，subB同理，</span>
<span style="font-size: 20px">
也都是采用运行时类型判断的。</span><br>
<span style="font-size: 20px">
&emsp;&emsp;⑤subA instance of SubClassB以及subB instance of SubClassA都出现了编译时报错，理由都是无法进行类型转换。这是因为</span>
<span style="font-size: 20px">
<mark>语法a instanceof ClassA需要a满足a的静态类型必须可以转换为ClassA，也就是说a的静态类型必须和ClassA在继承树的同一条路径上</mark>。<br>
&emsp;&emsp;⑥<mark>Java规定当instanceof的左边为null的话，运算结果为false</mark>。<br>
&emsp;&emsp;以上便是对instanceof运算符的简单介绍。关于instanceof运算符的具体原理以及一些比较深奥的技术细节，可以参考</span>
<span style="font-size: 20px">
<a href="https://www.cnblogs.com/ysocean/p/8486500.html#_label1">这篇博客</a>，里面有更详实的介绍。</span></div>

<h2 id="三-getClass-方法"><a href="#三-getClass-方法" class="headerlink" title="三. getClass()方法"></a>三. getClass()方法</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;接着是getClass()方法，它是Object类中一个final public的方法，说明所有的Java类都会拥有该方法且不能重写，其作用为</span>
<span style="font-size: 20px">
<mark>获得该对象的运行时类型。</mark>该方法由于涉及到Java反射的知识，我个人并未有很深的理解，因此这里只是通过一些简单的测试基本了解一下这个方法</span>
<span style="font-size: 20px">
是干嘛的，至于更深入的技术细节，已经超出了软件构造课的范围了。<br>
&emsp;&emsp;我们来测试一下，测试代码如下，测试结果已经以注释的形式写在了源代码中：</span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getClassTest() &#123;</span><br><span class="line">    SuperClass super1 &#x3D; new SuperClass(&quot;NAME&quot;, 1);</span><br><span class="line">    SuperClass super2 &#x3D; new SubClassA(&quot;NAME&quot;, 1, 100);</span><br><span class="line">    SuperClass super3 &#x3D; new SubClassB(&quot;NAME&quot;, 1, 101);</span><br><span class="line"></span><br><span class="line">    SubClassA subA &#x3D; new SubClassA(&quot;NAME&quot;, 1, 102);</span><br><span class="line">    SubClassB subB &#x3D; new SubClassB(&quot;NAME&quot;, 1, 103);</span><br><span class="line"></span><br><span class="line">    System.out.println(super1.getClass());</span><br><span class="line">    System.out.println(super2.getClass());</span><br><span class="line">    System.out.println(super3.getClass());</span><br><span class="line">    System.out.println(subA.getClass());</span><br><span class="line">    System.out.println(subB.getClass());</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 测试结果，其中UsedClasses为包名</span><br><span class="line">     * class UsedClasses.SuperClass</span><br><span class="line">     * class UsedClasses.SubClassA</span><br><span class="line">     * class UsedClasses.SubClassB</span><br><span class="line">     * class UsedClasses.SubClassA</span><br><span class="line">     * class UsedClasses.SubClassB</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;可以看到返回值表示的确实表示的是各个对象对应的运行时类。在本博客中，我们知道这一点就足够了。</span></div>

<h2 id="四-Object类里面的equals-方法的规约分析"><a href="#四-Object类里面的equals-方法的规约分析" class="headerlink" title="四. Object类里面的equals()方法的规约分析"></a>四. Object类里面的equals()方法的规约分析</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在重写Object类的equals()方法之前，我们当然需要了解并遵守其spec，让我们来看看它的spec：<br>
</span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br><span class="line">Indicates whether some other object is &quot;equal to&quot; this one.</span><br><span class="line">The equals method implements an equivalence relation on non-null object references:</span><br><span class="line">    * It is reflexive: for any non-null reference value x, x.equals(x) should return true.</span><br><span class="line">    * It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</span><br><span class="line">    * It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</span><br><span class="line">    * It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.</span><br><span class="line">    * For any non-null reference value x, x.equals(null) should return false.</span><br><span class="line">The equals method for class Object implements the most discriminating possible equivalence relation on objects; </span><br><span class="line">that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x &#x3D;&#x3D; y has the value true).</span><br><span class="line">Note that it is generally necessary to override the hashCode method whenever this method is overridden, </span><br><span class="line">so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</span><br></pre></td></tr></table></figure>

<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;可以看到我们重写equals()方法的时候，重写后的equals()方法需要满足以下5条性质：<br>
&emsp;&emsp;①<mark>自反性</mark><br>
&emsp;&emsp;②<mark>对称性</mark><br>
&emsp;&emsp;③<mark>传递性</mark><br>
&emsp;&emsp;④<mark>一致性</mark><br>
&emsp;&emsp;⑤<mark>对于任何非null的对象x，x.equals(null)==true</mark><br>
&emsp;&emsp;我们需要牢记这5点，在这篇博客剩下的部分，我们会时刻关注它们是否被满足。
</span></div>

<h2 id="四-IDEA自动生成equals-方法的原理分析"><a href="#四-IDEA自动生成equals-方法的原理分析" class="headerlink" title="四. IDEA自动生成equals()方法的原理分析"></a>四. IDEA自动生成equals()方法的原理分析</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;接下来我们正式进入对IDEA自动生成equals()方法的原理分析部分。以SuperClass为例，</span>
<span style="font-size: 20px">
我们来看看其是如何帮我们自动生成equals()方法的：<br>
&emsp;&emsp;首先在SuperClass代码所在的页面按下相应快捷键(我在IDEA中设置为ctrl+shift+s)，会弹出一个如下图所示的菜单。
</span></div>

<p><img src="https://z3.ax1x.com/2021/07/06/R78V1J.md.png" alt="P1"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;选择其中的equals() and hashCode()点击进入如下图所示的窗口：</span></div>

<p><img src="https://z3.ax1x.com/2021/07/06/R78gun.png" alt="P2"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在该窗口里有三个可选的部分：<br>
&emsp;&emsp;首先是选择Template模板，即选择按照什么样的代码风格来自动生成。
</span></div>


<p><img src="https://z3.ax1x.com/2021/07/06/R7GS8e.png" alt="P3"></p>
<div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;可以看到有IDEA的默认选择模板和Java 7+可用的模板，其区别主要在于Java 7+引入了Objects工具类，</span>
<span style="font-size: 20px">
里面提供的Objects.equals()和Objects.hash()两个静态方法可以用来很方便的重写Object类的equals()方法，鉴于课程使用的JDK环境为JDK 8及以上，</span>
<span style="font-size: 20px">
所以就选择采用这种模板来重写了。<br>
&emsp;&emsp;<mark>第二个可选部分并不建议，正如其下方提示所言，这种实现可能会违背之前我们所说的equals()方法的5条性质</mark>。事实上，在该实现方式中，</span>
<span style="font-size: 20px">
正是因为使用了instanceof运算符才导致可能违反规约的，之后我们来实际测试一下，这里我们先讲完让IDEA帮我们重写的完整操作步骤。<br>
&emsp;&emsp;第三个可选部分是采用相应的get方法获取属性的值，一般无特殊需求时按照默认不选择该选项即可。<br>
</span></div>

]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>软件构造</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
