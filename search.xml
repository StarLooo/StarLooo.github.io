<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown学习笔记</title>
    <url>/2021/05/08/markdown/</url>
    <content><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a><center>Markdown学习笔记</center></h1><h2 id="一-markdown的简要介绍"><a href="#一-markdown的简要介绍" class="headerlink" title="一. markdown的简要介绍"></a>一. markdown的简要介绍</h2><p>
&emsp;&emsp;根据<a href="http://markdown.p2hp.com/getting-started/">
Markdown中文网 </a>的描述：Markdown是一种轻量级的标记语言，
可用于将格式设置元素添加到纯文本文档中。 
Markdown由John Gruber于2004年创建，如今已成为世界上最受欢迎的标记语言之一。<br>  
&emsp;&emsp;本学期软件构造课和计算机系统课都有大量的实验任务, 
在完成实验后，写一写博客,留下一些记录，既能够帮助自己整理所学所感，
也能给后来者提供一些微不足道的教程和帮助。<br>
&emsp;&emsp;这是我第一次认真尝试写一篇博客，才疏学浅，希望能够起到抛砖引玉的作用。
此外，本文中由于hexo配置与markdown本身语法以及使用编辑器的种种桎梏，有些本应有效
的markdown语法在实际呈现到blog的时候出现了与预期不符的问题，<mark>所以为了解决这些
问题，我被迫使用了一些html语言</mark>，但是实际上我并没有系统学习过markdown或者是html，
所以很有可能写的不规范或者不具有可扩展性和可移植性。<br>
&emsp;&emsp;同时为了排版方便以及演示代码的展现，大部分博客文字内容都呈现在代码块。<br>
&emsp;&emsp;下面正式进入正文部分：
</p>

<span id="more"></span>

<h2 id="二-markdown语法之标题"><a href="#二-markdown语法之标题" class="headerlink" title="二. markdown语法之标题"></a>二. markdown语法之标题</h2><p>
&emsp;&emsp;依据<a href="http://markdown.p2hp.com/basic-syntax/">
官方文档 </a>，markdown一共支持从大到小共六级标题，其具体使用语法如下所示：<br>
</p>

<pre><code>    在markdown中可以使用&quot;k个#+空格+HeaderName&quot;就可以生成一个k级标题，
k为1到6的整数。
    注意，使用这种方式创建标题时必须与上面的段落之间空一行
    而在html中可以使用&lt;hk&gt;HeaderName&lt;/hk&gt;的方法生成相应级别的标题。
    标题的字体大小与级数有关，1级标题的字体最大，6级标题的字体最小。
    此外，还有一种生成1、2级标题的替代格式，此处不再赘述。
    为了不破坏本博客的标题结构，此处就不做演示了。
</code></pre>
<h2> 三. markdown语法之文字处理</h2>

<h4 id="1-换行"><a href="#1-换行" class="headerlink" title="1. 换行"></a>1. 换行</h4><pre><code>    在markdown中可以使用两个空格加enter键换行,但不知是hexo的配置原因
还是我用IDEA/Typro编写md文件的时候直接按enter就会自动换行，这样其实还
挺麻烦的，因为没有办法在一段较长的时候分割开段落，因为一按回车就会自动强
行换行。这也是为什么我要在代码里引入html的原因。
    在html中，换行只需要在上一行尾部加上&lt;\br&gt;即可。
    如果不显示地用上述方法换行的话，直接按enter并不会在显示的时候换行，
只是可以在编写的时候重新提行写，这样更人性化。
    下面使用&quot;&amp;emsp;&amp;emsp;&amp;emsp;这是第一行&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;
这是第二行&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;这是第一行<br>&emsp;&emsp;&emsp;这是第二行</p>
<h3 id="2-粗体和斜体"><a href="#2-粗体和斜体" class="headerlink" title="2. 粗体和斜体"></a>2. 粗体和斜体</h3><pre><code>    (1)
        在markdown中对某个字或者某段词句加粗的语法为：**想要加粗的文字**
    或者在html中用&lt;strong&gt;想要加粗的文字&lt;/strong&gt;的方式加粗。
    (2)
        在markdown中对某个字或者某段词句设为斜体的语法为：*想要倾斜的文字*
    或者在html中用&lt;em&gt;想要加粗的文字&lt;/em&gt;的方式加粗。
    (3)
        如果既想要加粗又想要斜体，可以这样写：***想要加粗并倾斜的文字***
    或者在html中用&lt;strong&gt;&lt;em&gt;想要加粗的文字&lt;/em&gt;&lt;/strong&gt;。
    
        下面使用&quot;&lt;strong&gt;&lt;em&gt;markdown使用笔记&lt;/em&gt;&lt;/strong&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<strong><em>markdown使用笔记</em></strong></p>
<h3 id="3-居中"><a href="#3-居中" class="headerlink" title="3. 居中"></a>3. 居中</h3><pre><code>    我不清楚markdown是否提供了将文字居中的语法，所以我学习了如何使用html
来将文字居中，其具体语法为：&lt;center&gt;想要居中的文字&lt;/center&gt;
    下面使用&quot;&lt;center&gt;我在中间&lt;/center&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<center>我在中间</center></p>
<h3 id="4-上脚标和下脚标"><a href="#4-上脚标和下脚标" class="headerlink" title="4. 上脚标和下脚标"></a>4. 上脚标和下脚标</h3><pre><code>    在typro中偏好设置里可以选择引入markdown扩展语法中的脚标：
    ^上脚标^和~下脚标~
    但是我使用了上述方式成功在编辑器里测试了上下脚标功能后运用
到博客并部署到hexo中时却发现实际显示的结果与本机上测试有所不同。
所以，被逼无奈，又只好寻求html这个法宝了：
    在html中，添加上下脚标的语法为：
    &lt;sup&gt;上角标&lt;/sup&gt;和&lt;sub&gt;下脚标&lt;/sub&gt;
    不过有一个待解决的问题是如何打出双脚标，个人推可能需要Latex
插件的支持用公式编辑的方法打出来吧。
    下面使用&quot;H&lt;sub&gt;2&lt;/sub&gt;O&quot;和2&quot;&lt;sup&gt;10&lt;/sup&gt;=1024&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;H<sub>2</sub>O &emsp; 2<sup>10</sup>=1024<br></p>
<h3 id="5-高亮"><a href="#5-高亮" class="headerlink" title="5. 高亮"></a>5. 高亮</h3><pre><code>    在typro中偏好设置里可以选择引入markdown扩展语法中的高亮：
    ==想要高亮的文字==
    但是我使用了上述方式成功在编辑器里测试了上下脚标功能后运用
到博客并部署到hexo中时却发现实际显示的结果与本机上测试有所不同。
所以，被逼无奈，又只好寻求html这个法宝了：
    在html中，添加上下脚标的语法为：&lt;mark&gt;想要高亮的语句&lt;/mark&gt;
    下面使用&quot;&lt;mark&gt;注意了注意了&lt;/mark&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<mark>注意了注意了</mark></p>
<h3 id="6-下划线和删除线"><a href="#6-下划线和删除线" class="headerlink" title="6. 下划线和删除线"></a>6. 下划线和删除线</h3><pre><code>    markdown语法中，删除线的实现方法为:~~想要画上删除线的内容~~ ；
    下划线的实现方法未知，html中可以这样写：&lt;u&gt;想要画上下划线的内容&lt;/u&gt;
    下面使用&quot;~~请无视这句话~~&quot;以及&quot;&lt;u&gt;划重点啦&lt;/u&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<del>请无视这句话</del> &emsp; <u>划重点啦</u></p>
<h3 id="6-空格"><a href="#6-空格" class="headerlink" title="6. 空格"></a>6. 空格</h3><pre><code>    一种打空格的方式是直接按space键或者tab键，但是为了更好地控制空白
的大小，可以使用html当中的空格：
    可以用&quot;&amp;nbsp;&quot;或者&quot;&amp;ensp;&quot;或者&quot;&amp;emsp&quot;等不同定义的空格来实现想
要的空白宽度，具体可以参照这篇博客：html空格的五种表示(https://www.
cnblogs.com/SimonHu1993/p/9257176.html)。
    下面使用&quot;|&amp;nbsp|---------|&amp;ensp|---------|&amp;emsp;|&quot;来演示这
三种空格的大小：
</code></pre>
<p>&emsp;&emsp;&emsp;|&nbsp;|———|&ensp;|———|&emsp;|</p>
<h2 id="四-markdown语法之链接与引用"><a href="#四-markdown语法之链接与引用" class="headerlink" title="四. markdown语法之链接与引用"></a>四. markdown语法之链接与引用</h2><h4 id="1-自动链接"><a href="#1-自动链接" class="headerlink" title="1. 自动链接"></a>1. 自动链接</h4><pre><code>    自动链接就是将地址原封不动的显示出来，同时它也将生成该地址的超链接，
它常用于邮箱地址和较短网址的显示。语法是在该链接地址前后加上一对&lt; &gt;，常
用于显示邮箱或者网址等等。
    比如，使用代码&quot;&lt;https://github.com/&gt;&quot;可以生成如下的自动链接：
</code></pre>
<p>&emsp;&emsp;&emsp;<a href="https://github.com/">https://github.com/</a></p>
<h4 id="2-文本链接"><a href="#2-文本链接" class="headerlink" title="2. 文本链接"></a>2. 文本链接</h4><pre><code>    markdown支持行内式(inline)和参考式(reference)两种形式的超文本链
接语法格式。不管是哪一种，链接文字都是用方括号&quot;[]&quot;来标记。
    首先是行内式，其markdown语法为&quot;[txt](url)&quot;，对应html语法为&lt;a hr
ef=&quot;url&quot;&gt;text&lt;/a&gt;。如果你还想要加上链接的title，只要在网址后面用双引
号把title文字包起来即可。
    然后是参考式，其用途主要是可以先声明超链接但是并不给出其定义，而是在
md文件的任何其他位置(一般是末尾)加以定义。其markdown语法为：先定义参考
refid：[text][refid]，再定义参考refid所指向的具体地址[refid]:url。
注意，这里有一些简写和细节问题，详情可以参考下述用于演示参考式的链接里的
博客。
    以下我们用html语法&lt;a href=&quot;https://starlooo.github.io/&quot;&gt;我的
博客主页&lt;/a&gt;来演示行内式文编链接；然后用markdown语法[一篇关于链接的参
考博客][ref_blog_1]和[ref_blog_1]:https://blog.csdn.net/baox
iao7872/article/details/90240402来演示参考式文本链接：
</code></pre>
<p>&emsp;&emsp;&emsp;<a href="https://starlooo.github.io/">我的博客主页</a><br><br>&emsp;&emsp;&emsp;<a href="https://blog.csdn.net/baoxiao7872/article/details/90240402">一篇关于链接的参考博客</a></p>
<h4 id="3-图片链接"><a href="#3-图片链接" class="headerlink" title="3. 图片链接"></a>3. 图片链接</h4><pre><code>    markdown使用与文本链接几乎相同的方式来实现图片链接，同样支持行内式
和参考式两种形式，只是需要在方括号前加上一个&quot;!&quot;。
    以行内式为例，图片链接的markdown语法为：![alt_txt](url)，对应ht
ml写法为&lt;img src=&quot;url&quot; alt=&quot;text&quot;&gt;，其中文本部分可选，如果没有需要可
以不写。
    但这里有个问题，我目前虽然可以把本地的图片链接入markdown，但当写博
客部署到云端后却发现图片无法加载。目前的解决方法是使用图床，将自己本地的
图片上传到网上，然后生成链接来引用。下面提供的链接的知乎回答里有关于一些
图床的介绍，读者可以自行选用。
    以下我们分别用markdown语法：[illustration_1](https://z3.ax1x
.com/2021/05/08/gGdtld.jpg)]和html语法&lt;img src=&quot;https://z3.ax1
x.com/2021/05/09/gYI9n1.jpg&quot; alt=&quot;gYI9n1.jpg&quot; border=&quot;0&quot; /&gt;来
演示图片链接：
</code></pre>
<p><img src="https://z3.ax1x.com/2021/05/08/gGdtld.jpg" alt="illustration_1"><br><img src="https://z3.ax1x.com/2021/05/09/gYI9n1.jpg" alt="illustrtion_2"></p>
<h4 id="4-块引用"><a href="#4-块引用" class="headerlink" title="4. 块引用"></a>4. 块引用</h4><pre><code>    markdown可以创建块引用，具体方法是在段落前添加一个&quot;&gt;&quot;，如果需要对
多个段落添加块引用需要在空行前也加上&quot;&gt;&quot;。
    同时，块引用可以嵌套使用，可以在一级块引用内使用&quot;&gt;&gt;&quot;创建二级块引用。
另一方面块引用的内部也可以使用markdown的其他语法元素，具体可以自行尝试。
    以下我们用&gt;**块引用段落1**&lt;br&gt;和&gt;*块引用段落2*&lt;br&gt;以及&gt;&gt;&lt;mark&gt;
嵌套块引用&lt;mark&gt;引用来演示块引用：
</code></pre>
<blockquote>
<p><strong>块引用段落1</strong><br><br><em>块引用段落2</em><br></p>
<blockquote>
<p><mark>嵌套块引用<mark></p>
</blockquote>
</blockquote>
<h4 id="5-代码和代码块"><a href="#5-代码和代码块" class="headerlink" title="5. 代码和代码块"></a>5. 代码和代码块</h4><pre><code>    markdown中可以标记行内代码，具体方法是使用一对反引号&quot;`&quot;将想要写的代码
框住，或者使用html语法中的&lt;code&gt;inline_code&lt;code&gt;。
    此外，markdown可以创建代码块，具体方法是在段代码块的每一行前缩进4个空
格或者1个制表符。另以种方式是把代码块框在一对“```”或者&quot;~~~&quot;之内。另外，根
据我的实验，使用4个空格或1个制表符的方式与使用3个反引号或波浪号框住的方式的
区别在于后者创建的代码块会标上行号。
    以下我们用&quot;`printf()`函数是C语言的基本输出函数&quot;和一段写有HelloMarkd
own程序的代码块来演示：
</code></pre>
<p><code>printf()</code>函数是C语言的基本输出函数<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Hello, markdown!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-markdown语法之列表与表格"><a href="#五-markdown语法之列表与表格" class="headerlink" title="五. markdown语法之列表与表格"></a>五. markdown语法之列表与表格</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1. 无序列表"></a>1. 无序列表</h3><pre><code>    可以使用在行首加上&quot;-&quot;或&quot;+&quot;或&quot;*&quot;标记的方式创建markdown无序列表。所谓
无序列表，指的是各表项间是并列关系，并没有相对先后顺序。渲染结果是一个小圈。
    此外可以在无序列表内部用同样的方式创建嵌套的无序列表。
    以下代码用来演示无序列表的创建:
    * 无序列表的演示,表项1
        - 无序列表的演示，子表项1
        + 无序列表的演示，子表项2

    * 无序列表的演示,表项2
</code></pre>
<ul>
<li>无序列表的演示,表项1<ul>
<li>无序列表的演示，子表项1</li>
</ul>
<ul>
<li>无序列表的演示，子表项2</li>
</ul>
</li>
<li>无序列表的演示,表项2        </li>
</ul>
<h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2. 有序列表"></a>2. 有序列表</h3><pre><code>    可以使用在行首加上”x.“标记的方式创建markdown有序列表，其中x为相应数字。
所谓有序列表，指的是各表项间是递进关系，有相对先后顺序。渲染结果是一个从1开始
按顺序拍下去的各表项，而子表项用排序渲染出的是对应罗马数字。
    此外可以在有序列表用相同的方式创建嵌套的有序列表，甚至可以用创建无序列表
的方式嵌套无序列表，反之亦然。
    以下代码用来演示有序列表的创建:
    1. 有序列表的演示,表项1
        1. 有序列表的演示，子表项1
        2. 有序列表的演示，子表项2

    2. 有序列表的演示,表项2
</code></pre>
<ol>
<li><p>有序列表的演示,表项1</p>
<ol>
<li>有序列表的演示，子表项1</li>
<li>有序列表的演示，子表项2</li>
</ol>
</li>
<li><p>有序列表的演示,表项2</p>
</li>
</ol>
<h3 id="3-表格"><a href="#3-表格" class="headerlink" title="3. 表格"></a>3. 表格</h3><pre><code>    markdown支持使用&quot;|&quot;分割各表格项以及标记表格的行首行尾的方式创建表格，其中
行首行尾的&quot;|&quot;可以省略。第一行一般用于写每列的列名，列名采取居中对齐方式。
    在对齐方面，可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，可以在
相应位置写入&quot;-:&quot;表示这列的文字采用右对齐，同理&quot;:-&quot;表示左对齐，&quot;:-:&quot;表示居中对
齐。此外，需要注意创建表格时需要与上一段有一个空行，不然无法被识别。
    不知道是什么原因，在我使用IDEA编写md文件时，第二行里如果只使用一个&quot;-&quot;的话
实时渲染的结果并没有创建出对应表格，但实际上部署到云端博客的时候是创建了相应表格
的。但为了本地测试方便，我还是写了3个以上的&quot;-&quot;让IDEA识别出表格。
    以下代码用来演示创建表格：
    | 左对齐列 | 右对齐列 | 居中对齐列 |
    | :------| ------: | :------: |
    | 短文本 | 中等文本 | 稍微长一点的文本 |
    | 稍微长一点的文本 | 短文本 | 中等文本 |
</code></pre>
<table>
<thead>
<tr>
<th align="left">左对齐列</th>
<th align="right">右对齐列</th>
<th align="center">居中对齐列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">短文本</td>
<td align="right">中等文本</td>
<td align="center">稍微长一点的文本</td>
</tr>
<tr>
<td align="left">稍微长一点的文本</td>
<td align="right">短文本</td>
<td align="center">中等文本</td>
</tr>
</tbody></table>
<p>以下是两篇有关于markdown表格的参考博客:</p>
<p><a href="https://www.jianshu.com/p/2df05f279331">Markdown插入表格语法</a></p>
<p><a href="https://blog.csdn.net/tuxingchen6/article/details/55222951">利用Markdown创建表格</a></p>
]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>markdown</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类学习笔记序章</title>
    <url>/2021/05/19/collection_0/</url>
    <content><![CDATA[<h1 id="Java集合类学习笔记序章"><a href="#Java集合类学习笔记序章" class="headerlink" title="Java集合类学习笔记序章"></a><center>Java集合类学习笔记序章</center></h1><h2 id="一-系列简介"><a href="#一-系列简介" class="headerlink" title="一. 系列简介"></a>一. 系列简介</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在软件构造课程的学习过程中，对Java编程语言的不断</span>
<span style="font-size: 20px">
学习和练习是至关重要的。其中，通过对于Java JDK当中提供的各种各</span>
<span style="font-size: 20px">
样的容器的使用方法的学习能够极大地提高我们的编程能力。而JDK中</span>
<span style="font-size: 20px">
最常用的一类容器，莫过于<a href="https://docs.oracle.com/javase
/8/docs/api/java/util/Collection.html">集合Collection</a>了。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;因此，在学习Java Collection接口以及各个常见的实现类的过程当</span>
<span style="font-size: 20px">
中，撰写一系列博客来记录学习的过程和心得体会是有必要的。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;然而，由于Java集合及其各种实现类源码本身涉及到复杂的Java语法，</span>
<span style="font-size: 20px">
比如多线程、注解等，以及其具体实现的精妙性、复杂性，<mark>很难保证该系列博客中记录的我个人的理解是正确无误的。</mark><br></span>
<span style="font-size: 20px">
&emsp;&emsp;此外，受限于个人对Java的理解水平有限，以及时间精力等多重因素的</span>
<span style="font-size: 20px">
限制，所以<mark>一些细节的部分无法做到面面俱到，只是对一些学习到的知识随手记录</mark>，</span>
<span style="font-size: 20px">
系统性和逻辑性都略有不足。可做抛砖引玉之用。<br></span>
</div>

<span id="more"></span>

<h2 id="二-系列博客的内容组成"><a href="#二-系列博客的内容组成" class="headerlink" title="二. 系列博客的内容组成"></a>二. 系列博客的内容组成</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在我的预想中，接下来这一系列博客将基本按以下的方式进行组织： <br></span>
<span style="font-size: 20px">
&emsp;&emsp;首先是命名，除了本章序章以外，基本按照第一章XX、第二章XX这样的方式</span>
<span style="font-size: 20px">
依次命名下去。其中XX是具体对此章内容的总体概括。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;然后是具体的各章内容，目前是这样计划的：<br>
&emsp;&emsp;(1)<br>&emsp;&emsp;&emsp;&emsp;首先是<a href="http://localhost:4000/2021/05/19/collection_0/">序章</a></span>
<span style="font-size: 20px">对系列博客的基本介绍以及为一些关键的说明作预留，以及一些可能<br></span>
<span style="font-size: 20px">&emsp;&emsp;有用的参考的资料的整理。<br>
&emsp;&emsp;(2)<br>&emsp;&emsp;&emsp;&emsp;然后是<a href="http://localhost:4000/2021/05/19/collection_1/">第一章</a></span>
<span style="font-size: 20px">，用来介绍Java迭代器接口Iterator和可迭代接口Iterable，他们对于<br></span>
<span style="font-size: 20px">&emsp;&emsp;后续集合的遍历非常有用，因此在第一章，我们尽可能将</span>
<span style="font-size: 20px">其常见的使用方法一网打尽。<br>
&emsp;&emsp;(3)<br>&emsp;&emsp;&emsp;&emsp;然后是第三章，正式进入对集合的整理，在这一章我们将</span>
<span style="font-size: 20px">对Collection接口中的所<br>
&emsp;&emsp;有抽象方法做详细理解，并通过其各种实现类进行相应的测试。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;(4)<br>&emsp;&emsp;&emsp;&emsp;然后是第三、四、五章，在这几章我们将</span>
<span style="font-size: 20px">对Collection接口的常见实现类中的中的<br>
&emsp;&emsp;常用方法做详细理解，并进行相应的测试，也会涉及到相当一些源码的阅读分析。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;(5)<br>&emsp;&emsp;&emsp;&emsp;To Be Continued!<br></span>
</div>

<h2 id="三-参考资料汇总"><a href="#三-参考资料汇总" class="headerlink" title="三. 参考资料汇总"></a>三. 参考资料汇总</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;<a href="https://docs.oracle.com/javase/8/docs/api/">Java JDK8官方API英文版</a><br>
&emsp;&emsp;<a href="https://www.matools.com/api/java8">Java JDK8官方API中文版</a></span>
<span style="font-size: 20px"><mark>(注意，机翻质量极低，不建议大量使用)</mark><br>
&emsp;&emsp;<a href="https://blog.csdn.net/u011240877/category_6447444.html">
一系列关于Java集合框架的原理分析博客</a>&emsp;&emsp;作者：拭心<br></span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;<br></span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;<br></span>
</div>



]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类学习笔记第一章--迭代器</title>
    <url>/2021/05/21/collection_1/</url>
    <content><![CDATA[<h1 id="Java集合类学习笔记第一章–迭代器"><a href="#Java集合类学习笔记第一章–迭代器" class="headerlink" title="Java集合类学习笔记第一章–迭代器"></a><center>Java集合类学习笔记第一章–迭代器</center></h1><h2 id="一-本章概述"><a href="#一-本章概述" class="headerlink" title="一. 本章概述"></a>一. 本章概述</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在本章中，主要介绍Java迭代器的有关内容。<br>
&emsp;&emsp;要讲集合，首先得讲清楚迭代器。在JDK中可以从接口声明中清楚的看到<a href="https://doc
s.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>接口继承自</span>
<span style="font-size: 20px">
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterable.html">Iterable</a>接口。<br>
&emsp;&emsp;而迭代器<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">
Iterator</a>接口</span>
<span style="font-size: 20px">,具体到其在各种集合类中对应的实现，为我们提供了有效地访问、遍历不同类型的集合中元素的方法。<br>
&emsp;&emsp;因此，我把对Iterable和Iterator这两个接口的学习放到了第一章。本章的学习目的为：</span>
<span style="font-size: 20px">
基本掌握Java迭代器在集合类当中的使用，同时对迭代器使用过程中的有关注意事项有一个清楚的认知。<br></span></div>

<span id="more"></span>

<h2 id="二-迭代器接口和可迭代接口的基本介绍"><a href="#二-迭代器接口和可迭代接口的基本介绍" class="headerlink" title="二. 迭代器接口和可迭代接口的基本介绍"></a>二. 迭代器接口和可迭代接口的基本介绍</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;根据官方API中对Iterable可迭代接口的说明:"Implementing this interface allows an object to be the target </span>
<span style="font-size: 20px">of the "for-each loop" statement."，实现了Iterable接口的对象就可以使用for-each循环。那么，</span>
<span style="font-size: 20px">什么是for-each循环呢?<br>
&emsp;&emsp;for-each循环，又称增强for循环，是JDK5的新特性中定义的一种新的循环语法，语法的标准格式为：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for( 数据类型 变量名 : 遍历的目标对象 ) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;最常见的比如数组就支持for-each循环，以下是用普通for循环和增强for循环对数组遍历的示例程序：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void loopTest() &#123;</span><br><span class="line">    int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">    System.out.println(&quot;普通for循环:&quot;);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;\n增强for循环:&quot;);</span><br><span class="line">    for(int num : arr) &#123;</span><br><span class="line">        System.out.print(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="font-size: 20px">&emsp;&emsp;执行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/20/gIgQP0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;根据官方API，Iterable接口中的定义为：<code>public Interface Iterable&lt;T&gt;</code>，内部的抽象方法只有一个:</span>
<span style="font-size: 20px"><code>Iterator&lt;T&gt;iterator()</code></span>
<span style="font-size: 20px">其作用为返回一个元素类型为T的迭代器。所有实现了Iterable的接口都实现了这个方法，特别的，集合也是。<br>
&emsp;&emsp;接着我们看看Iterator接口的API，接口定义为：<code>public Interface Iterator<&#917;></code>。官方文档对其有如下的解释：
<br>&emsp;&emsp;Iterator是用来替代原来集合框架中的<a href="">Enumeration</a>接口的，</span>
<span style="font-size: 20px">其相比Enumeration接口，有以下两个变化：其一是迭代器允许调用者在迭代过程中使用定义明确的语义</span>
<span style="font-size: 20px">从集合中删除元素；其二是对方法的命名有所改进。第一点中所谓定义明确的语义，听起来有点费解</span>
<span style="font-size: 20px">我们会在接下来的小节研究这一部分的内容，这里就先跳过了。<br>
&emsp;&emsp;Iterator中声明了两个抽象方法和两个默认方法，其中最重要也是最常用的三个方法分别为：<br>
&emsp;&emsp;<code>boolean hasNext()</code> ，作用为判断迭代是否还有下一个元素。换句话说，当该方法返回true时，调用next方法</span>
<span style="font-size: 20px">会返回下一个元素而不是抛出异常<br>
&emsp;&emsp;<code>E    next()</code> ，作用为返回迭代的下一个元素，如果迭代已经没有下一个元素了，则会抛出NoSuchElementException。<br>
&emsp;&emsp;<code>default void remove()</code> ，作用为从集合中移除此迭代器最近返回的那个元素。</span>
<span style="font-size: 20px">关于该默认方法有一些注意事项，我们会在第三小节中详细说明。<br></span>
</div>


<h2 id="三-Iterator接口的详细介绍"><a href="#三-Iterator接口的详细介绍" class="headerlink" title="三. Iterator接口的详细介绍"></a>三. Iterator接口的详细介绍</h2><div style="font-size: 20px">
&emsp;&emsp;下面仔细研究一下Iterator接口中的这三个方法，使用集合类中大家最熟悉的ArrayList做测试。<br></div>

<h3 id="part1–hasNext方法"><a href="#part1–hasNext方法" class="headerlink" title="part1–hasNext方法"></a>part1–hasNext方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns true if the iteration has more elements.</mark></span>
<span style="font-size: 20px"><mark>(In other words, returns true if next() would return an element
rather than throwing an exception.)</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void hasNextTest() &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">        Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        arraylist.add(1);</span><br><span class="line">        &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">        it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;空迭代器调用hasNext方法会抛出NullPointerException</span><br><span class="line">        ArrayList&lt;Integer&gt; null_arr &#x3D; null;</span><br><span class="line">        Iterator&lt;Integer&gt; null_it &#x3D; null_arr.iterator();</span><br><span class="line">        System.out.println(null_it.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZYnA.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，第一次获取arraylist的迭代器的时候，arraylist为空，所以it.hasNext输出为false; 而第二次获取arraylist</span>
<span style="font-size: 20px">迭代器的时候，arraylist中有一个元素1，所以it.hasNext输出为true; 接着我们定义了一个空的ArrayList对象，</span>
<span style="font-size: 20px">获得了它的迭代器，此时这个迭代器为空，若对空迭代器调用hasNext方法，则会产生NullPointerException异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part2–next方法"><a href="#part2–next方法" class="headerlink" title="part2–next方法"></a>part2–next方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns the next element in the iteration.</mark></span>
<span style="font-size: 20px"><mark>Throws NoSuchElementException if the iteration has no more elements.</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void nextTest() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line"></span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果it.hasNext()为false的时候调用it.next会产生NoSuchElementException</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZIc4.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在while循环的循环判断中，我们使用it.hasNext()来判断迭代是否有下一个元素，当迭代有下个元素的时候，</span>
<span style="font-size: 20px">我们再调用it.next()，此时可以保证it.next()返回的是下一个元素而不会抛出异常。</span>
<span style="font-size: 20px"><mark>这也是一种标准的非常建议的迭代器的使用方法</mark>，我们会在第四节中再提及这一点。<br>
&emsp;&emsp;根据打印结果，说明每次调用next()方法，在得到下一个元素的同时，迭代器的位置都会发生移动，使得下一次调用next()方法的时候</span>
<span style="font-size: 20px">迭代的下一个元素(如果有的话)是当前next()返回元素的下一个。具体到示例程序中，就是依次返回1、2、3。<br>
&emsp;&emsp;接着，程序退出while循环，说明hasNext()返回值为false，此时迭代到了末尾，已经没有下一个元素了，如果此时调用next()方法</span>
<span style="font-size: 20px">就会像API中规定的那样，抛出NoSuchElement异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part3–remove方法"><a href="#part3–remove方法" class="headerlink" title="part3–remove方法"></a>part3–remove方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Removes from the underlying collection
the last element returned by this iterator (optional operation). This method can be called only
once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified 
while the iteration is in progress in any way other than by calling this method.</mark></span>
<span style="font-size: 20px"><mark>Throws:UnsupportedOperationException if the remove operation
is not supported by this iterator. Throws IllegalStateException if the next method has not yet 
been called, or the remove method has already been called after the last call to the next method.</mark><br>
&emsp;&emsp;这个说明文档非常长，里面涉及的值得注意的地方也很多，其中最关键的便是以下四点：<br>
&emsp;&emsp;(1) remove()删除的是该迭代器最近返回的元素，即上一次调用next()返回的那一个元素。<br>
&emsp;&emsp;(2) 每次调用next()后，至多调用一次remove()，否则会抛出IllegalStateException异常。<br>
&emsp;&emsp;(3) 不能未经调用next()就直接调用remove()，否则也会抛出IllegalStateException异常。<br>
&emsp;&emsp;(4) 如果在迭代正在进行中以除调用该remove()方法之外的任何方式修改这个集合，则迭代器的行为未定义。<br>
&emsp;&emsp;我们来研究测试一下第(4)，这有助于我们理解为什么在很多集合类比如ArrayList本身拥有remove()方法的前提下，JDK</span>
<span style="font-size: 20px">在Iterator中还要提供迭代器专有的remove()方法：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void removeTest1() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中不删除元素</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中正确使用Iterator专有的remove()方法删除元素</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(&quot;当前迭代元素：&quot; + it.next());</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;***************************************&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;此时arraylist中的所有元素都在迭代的过程中被迭代器的remove()方法正确删除了</span><br><span class="line">    System.out.println(arraylist.size());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;***************************************&quot;);</span><br><span class="line"></span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line">    &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;迭代过程中错误使用ArrayList类中的remove()方法删除元素，注意，这是绝对不建议的行为</span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        Integer ele &#x3D; it.next();</span><br><span class="line">        System.out.println(&quot;当前迭代元素：&quot; + ele);</span><br><span class="line">        &#x2F;&#x2F;能删除成功，但是删除成功后迭代器将产生API中未定义的行为</span><br><span class="line">        System.out.println(arraylist.remove(ele));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g71enU.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，示例程序在第一部分展现的是正常的迭代并输出，在迭代的过程中我们没有使用任何的删除方法。第二部分中，在while循环里</span>
<span style="font-size: 20px">每调用一次next()方法后，我们调用一次Iterator专有的remove()方法删除集合中的元素，最后迭代结束后打印</span>
<span style="font-size: 20px">arraylist的元素个数，发现是0。并且整个迭代过程中并没有抛出任何异常，说明我们的使用是正确的。实际上，</span>
<span style="font-size: 20px"><mark>这是我们极其建议的API中规定的使用方法</mark>。<br>
&emsp;&emsp;反之，在第三部分中，我们尝试进行跟第二部分几乎一样的过程，唯一的不同在于删除元素的时候，我们尝试使用ArrayList中</span>
<span style="font-size: 20px">的remove方法而不是迭代器的remove方法。<mark>这是我们极不建议的方法</mark>，</span>
<span style="font-size: 20px">事实上，这回导致(4)中的严重问题。执行结果表明在第一次删除元素1之后，再次进入循环后，调用</span>
<span style="font-size: 20px">迭代器next方法时发生了错误，抛出了ConcurrentModificationException异常。</span>
<span style="font-size: 20px">应当是错误的删除操作破坏了迭代器的结构，使得迭代器无法按照其具体实现的代码逻辑正常执行功能。<br>
&emsp;&emsp;<mark>所以在使用迭代器迭代的过程中，务必遵照API的要求，只能使用迭代器中提供的方法修改集合的元素。</mark><br>
&emsp;&emsp;接下来我们来看看(2)和(3)的测试：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void removeTest2() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;测试调用1次next()后调用2次remove(),会抛出IllegalStateException异常</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    it.remove();</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void removeTest3() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    Iterator&lt;Integer&gt; it;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    it &#x3D; arraylist.iterator();</span><br><span class="line">    &#x2F;&#x2F;测试未调用next()直接调用remove(),也会抛出IllegalStateException异常</span><br><span class="line">    it.remove();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果分别如下：<br></span><br><span style="font-size: 20px">&emsp;&emsp;removeTest2()：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7Gf4H.png" alt="illustration_1"><br><br><br><span style="font-size: 20px">&emsp;&emsp;removeTest3()：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7G58A.png" alt="illustration_2"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，示例程序removeTest2在调用1次next()后调用2次remove(),会按(2)中所说的那样，</span>
<span style="font-size: 20px">抛出IllegalStateException异常。而示例程序removeTest3在未调用next()时直接调用</span>
<span style="font-size: 20px">remove()方法,会按(3)中所说的那样，也会抛出一个IllegalStateException异常。<br>
&emsp;&emsp;因此，在使用迭代器的remove的方法时，一定要确保调用remove()前要先调用next(),并且每调用一次next()，</span>
<span style="font-size: 20px">最多只能调用一次remove()。<br>
&emsp;&emsp;举个形式化的例子，设n的初始值为0，在集合元素足够多的情况下，每调用一次next()使n的值置为1，而每调用一次remove()使n减小1，</span>
<span style="font-size: 20px">一个合法的调用序列需要满足任意时刻n的值非负。<br>
&emsp;&emsp;比如next()->next()->remove()->next()->remove()->next()就是一个合法的调用序列，对应n的变化为：</span>
<span style="font-size: 20px">0->1->1->0->1->0->1。而next()->next()->remove()->next()->remove()->remove()</span>
<span style="font-size: 20px">就是一个非法的调用序列对应n的变化为：</span>
<span style="font-size: 20px">0->1->1->0->1->0->-1(非法)。<br></span></div>

<h2 id="四-for循环、for-each循环与迭代器"><a href="#四-for循环、for-each循环与迭代器" class="headerlink" title="四. for循环、for-each循环与迭代器"></a>四. for循环、for-each循环与迭代器</h2><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;到目前未知，我们一共有三种备选的方法可以用于对集合对象进行循环遍历，分别为：for循环、for-each循环(enhanced-for循环)</span>
<span style="font-size: 20px">与使用对应的迭代器迭代。我们首先各自分析它们的特点，然后进行对比分析，尝试得出对比的结论。<br></span></div>

<h3 id="part1–for循环"><a href="#part1–for循环" class="headerlink" title="part1–for循环"></a>part1–for循环</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;for循环十分简单，我们经常在数组循环的时候使用这种方法，以下是一段非常常见的for循环代码：<br>
</span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void forloopTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            Integer now &#x3D; arraylist.get(i); &#x2F;&#x2F;顺序结构的arraylist的for循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            Integer now &#x3D; linkedlist.get(i); &#x2F;&#x2F;链式结构的linklist的for循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;for循环示例程序中的内层for循环的平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7XVkn.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在该for循环示例程序中我们先通过一系列手段声明并初始化两个长度10000的List,其中一个是顺序结构的arraylisr，</span>
<span style="font-size: 20px">另一个是链式结构的linkedlist。接着进行100次相同的循环，每次外循环里都嵌套两个内循环，内循环里分别依次获得这</span>
<span style="font-size: 20px">两个List各自对应下标的元素。最后分别打印出两种结构这100次内层for循环的平均执行时间。</span>
<span style="font-size: 20px">结果为：<mark>顺序结构为0.01ms，链式结构为33.65ms</mark>,这个数据在今后我们做对比的时候还会用到。<br>
</span></div>

<h3 id="part2–for-each循环"><a href="#part2–for-each循环" class="headerlink" title="part2–for-each循环"></a>part2–for-each循环</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;IDEA有时会提醒你可以for-each循环替代某些for循环，这应当是有其内在原因的，以下是一段与part1中对应代码逻辑一致代码</span>
<span style="font-size: 20px">只不过内层循环的实现采用了for-each循环：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void forEachloopTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(Integer ele : arraylist) &#123;</span><br><span class="line">            Integer now &#x3D; ele; &#x2F;&#x2F;顺序结构的arraylist的forEach循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        for(Integer ele : linkedlist) &#123;</span><br><span class="line">            Integer now &#x3D; ele; &#x2F;&#x2F;链式结构的linklist的forEach循环</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;forEach循环示例程序中的内层forEach循环的平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7vTS0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，该forEach循环示例程序与for循环示例程序基本一样，只不过循环的方式改成了for-each循环</span>
<span style="font-size: 20px">最后分别打印出两种结构这100次内层for循环的平均执行时间。结果为：</span>
<span style="font-size: 20px"><mark>顺序结构为0.18ms，链式结构为0.08ms</mark>,这个数据在今后我们做对比的时候还会用到。<br></span></div>

<h3 id="part3–迭代器"><a href="#part3–迭代器" class="headerlink" title="part3–迭代器"></a>part3–迭代器</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;而我们之前讲的迭代器呢？它与for循环和forEach循环直接有什么关系，来看下面一段示例程序，</span>
<span style="font-size: 20px">同样，与par1和part2中的代码相比，par3中程序只是将原本的内层循环改为了迭代器迭代：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void iterationTest() &#123;</span><br><span class="line">    Integer[] data &#x3D; new Integer[10000];</span><br><span class="line">    Arrays.fill(data, 0);</span><br><span class="line">    &#x2F;&#x2F;Arrays.asList返回的实际上是一个ArrayList</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;(Arrays.asList(data));  &#x2F;&#x2F;顺序结构</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedlist &#x3D; new LinkedList&lt;&gt;(arraylist); &#x2F;&#x2F;链式结构</span><br><span class="line">    double arr_time &#x3D; 0;</span><br><span class="line">    double link_time &#x3D; 0;</span><br><span class="line">    long startTime,endTime;</span><br><span class="line">    for(int t &#x3D; 0; t &lt; 100; ++t) &#123;</span><br><span class="line">        Iterator&lt;Integer&gt; arr_it &#x3D; arraylist.iterator();</span><br><span class="line">        Iterator&lt;Integer&gt; link_it &#x3D; linkedlist.iterator();</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        while(arr_it.hasNext()) &#123;</span><br><span class="line">            Integer now &#x3D; arr_it.next(); &#x2F;&#x2F;顺序结构的arraylist的迭代</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        arr_time +&#x3D; (endTime - startTime);</span><br><span class="line">        startTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环开始的时间,单位为ms</span><br><span class="line">        while(link_it.hasNext()) &#123;</span><br><span class="line">            Integer now &#x3D; link_it.next();&#x2F;&#x2F;链式结构的linklist的迭代</span><br><span class="line">        &#125;</span><br><span class="line">        endTime&#x3D;System.currentTimeMillis(); &#x2F;&#x2F;获取循环结束的时间,单位为ms</span><br><span class="line">        link_time +&#x3D; (endTime - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    arr_time&#x2F;&#x3D;100;</span><br><span class="line">    link_time&#x2F;&#x3D;100;</span><br><span class="line">    System.out.println(&quot;迭代示例程序中的迭代平均执行时间分别为：&quot;+</span><br><span class="line">            &quot;顺序结构--&quot; + arr_time + &quot;ms&quot; + &quot;链式结构--&quot; + link_time + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7zorT.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，该迭代示例程序与for循环示例程序和for-each循环示例程序基本一样，只不过把循环改成了迭代</span>
<span style="font-size: 20px">最后分别打印出两种结构这100次内层for循环的平均执行时间。结果为：</span>
<span style="font-size: 20px"><mark>顺序结构为0.03ms，链式结构为0.1ms</mark>,这个数据在今后我们做对比的时候还会用到。<br></span></div>


<h2 id="五-ListIterator简介"><a href="#五-ListIterator简介" class="headerlink" title="五. ListIterator简介"></a>五. ListIterator简介</h2><p><span style="font-size: 20px">&emsp;&emsp;To Be Continued!<br></span></p>
<h2 id="六-参考资料"><a href="#六-参考资料" class="headerlink" title="六. 参考资料"></a>六. 参考资料</h2>]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
</search>
