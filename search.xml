<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown学习笔记</title>
    <url>/2021/05/08/markdown/</url>
    <content><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a><center>Markdown学习笔记</center></h1><h2 id="一-markdown的简要介绍"><a href="#一-markdown的简要介绍" class="headerlink" title="一. markdown的简要介绍"></a>一. markdown的简要介绍</h2><p>
&emsp;&emsp;根据<a href="http://markdown.p2hp.com/getting-started/">
Markdown中文网 </a>的描述：Markdown是一种轻量级的标记语言，
可用于将格式设置元素添加到纯文本文档中。 
Markdown由John Gruber于2004年创建，如今已成为世界上最受欢迎的标记语言之一。<br>  
&emsp;&emsp;本学期软件构造课和计算机系统课都有大量的实验任务, 
在完成实验后，写一写博客,留下一些记录，既能够帮助自己整理所学所感，
也能给后来者提供一些微不足道的教程和帮助。<br>
&emsp;&emsp;这是我第一次认真尝试写一篇博客，才疏学浅，希望能够起到抛砖引玉的作用。
此外，本文中由于hexo配置与markdown本身语法以及使用编辑器的种种桎梏，有些本应有效
的markdown语法在实际呈现到blog的时候出现了与预期不符的问题，<mark>所以为了解决这些
问题，我被迫使用了一些html语言</mark>，但是实际上我并没有系统学习过markdown或者是html，
所以很有可能写的不规范或者不具有可扩展性和可移植性。<br>
&emsp;&emsp;同时为了排版方便以及演示代码的展现，大部分博客文字内容都呈现在代码块。<br>
&emsp;&emsp;下面正式进入正文部分：
</p>

<span id="more"></span>

<h2 id="二-markdown语法之标题"><a href="#二-markdown语法之标题" class="headerlink" title="二. markdown语法之标题"></a>二. markdown语法之标题</h2><p>
&emsp;&emsp;依据<a href="http://markdown.p2hp.com/basic-syntax/">
官方文档 </a>，markdown一共支持从大到小共六级标题，其具体使用语法如下所示：<br>
</p>

<pre><code>    在markdown中可以使用&quot;k个#+空格+HeaderName&quot;就可以生成一个k级标题，
k为1到6的整数。
    注意，使用这种方式创建标题时必须与上面的段落之间空一行
    而在html中可以使用&lt;hk&gt;HeaderName&lt;/hk&gt;的方法生成相应级别的标题。
    标题的字体大小与级数有关，1级标题的字体最大，6级标题的字体最小。
    此外，还有一种生成1、2级标题的替代格式，此处不再赘述。
    为了不破坏本博客的标题结构，此处就不做演示了。
</code></pre>
<h2> 三. markdown语法之文字处理</h2>

<h4 id="1-换行"><a href="#1-换行" class="headerlink" title="1. 换行"></a>1. 换行</h4><pre><code>    在markdown中可以使用两个空格加enter键换行,但不知是hexo的配置原因
还是我用IDEA/Typro编写md文件的时候直接按enter就会自动换行，这样其实还
挺麻烦的，因为没有办法在一段较长的时候分割开段落，因为一按回车就会自动强
行换行。这也是为什么我要在代码里引入html的原因。
    在html中，换行只需要在上一行尾部加上&lt;\br&gt;即可。
    如果不显示地用上述方法换行的话，直接按enter并不会在显示的时候换行，
只是可以在编写的时候重新提行写，这样更人性化。
    下面使用&quot;&amp;emsp;&amp;emsp;&amp;emsp;这是第一行&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;
这是第二行&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;这是第一行<br>&emsp;&emsp;&emsp;这是第二行</p>
<h3 id="2-粗体和斜体"><a href="#2-粗体和斜体" class="headerlink" title="2. 粗体和斜体"></a>2. 粗体和斜体</h3><pre><code>    (1)
        在markdown中对某个字或者某段词句加粗的语法为：**想要加粗的文字**
    或者在html中用&lt;strong&gt;想要加粗的文字&lt;/strong&gt;的方式加粗。
    (2)
        在markdown中对某个字或者某段词句设为斜体的语法为：*想要倾斜的文字*
    或者在html中用&lt;em&gt;想要加粗的文字&lt;/em&gt;的方式加粗。
    (3)
        如果既想要加粗又想要斜体，可以这样写：***想要加粗并倾斜的文字***
    或者在html中用&lt;strong&gt;&lt;em&gt;想要加粗的文字&lt;/em&gt;&lt;/strong&gt;。
    
        下面使用&quot;&lt;strong&gt;&lt;em&gt;markdown使用笔记&lt;/em&gt;&lt;/strong&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<strong><em>markdown使用笔记</em></strong></p>
<h3 id="3-居中"><a href="#3-居中" class="headerlink" title="3. 居中"></a>3. 居中</h3><pre><code>    我不清楚markdown是否提供了将文字居中的语法，所以我学习了如何使用html
来将文字居中，其具体语法为：&lt;center&gt;想要居中的文字&lt;/center&gt;
    下面使用&quot;&lt;center&gt;我在中间&lt;/center&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<center>我在中间</center></p>
<h3 id="4-上脚标和下脚标"><a href="#4-上脚标和下脚标" class="headerlink" title="4. 上脚标和下脚标"></a>4. 上脚标和下脚标</h3><pre><code>    在typro中偏好设置里可以选择引入markdown扩展语法中的脚标：
    ^上脚标^和~下脚标~
    但是我使用了上述方式成功在编辑器里测试了上下脚标功能后运用
到博客并部署到hexo中时却发现实际显示的结果与本机上测试有所不同。
所以，被逼无奈，又只好寻求html这个法宝了：
    在html中，添加上下脚标的语法为：
    &lt;sup&gt;上角标&lt;/sup&gt;和&lt;sub&gt;下脚标&lt;/sub&gt;
    不过有一个待解决的问题是如何打出双脚标，个人推可能需要Latex
插件的支持用公式编辑的方法打出来吧。
    下面使用&quot;H&lt;sub&gt;2&lt;/sub&gt;O&quot;和2&quot;&lt;sup&gt;10&lt;/sup&gt;=1024&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;H<sub>2</sub>O &emsp; 2<sup>10</sup>=1024<br></p>
<h3 id="5-高亮"><a href="#5-高亮" class="headerlink" title="5. 高亮"></a>5. 高亮</h3><pre><code>    在typro中偏好设置里可以选择引入markdown扩展语法中的高亮：
    ==想要高亮的文字==
    但是我使用了上述方式成功在编辑器里测试了上下脚标功能后运用
到博客并部署到hexo中时却发现实际显示的结果与本机上测试有所不同。
所以，被逼无奈，又只好寻求html这个法宝了：
    在html中，添加上下脚标的语法为：&lt;mark&gt;想要高亮的语句&lt;/mark&gt;
    下面使用&quot;&lt;mark&gt;注意了注意了&lt;/mark&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<mark>注意了注意了</mark></p>
<h3 id="6-下划线和删除线"><a href="#6-下划线和删除线" class="headerlink" title="6. 下划线和删除线"></a>6. 下划线和删除线</h3><pre><code>    markdown语法中，删除线的实现方法为:~~想要画上删除线的内容~~ ；
    下划线的实现方法未知，html中可以这样写：&lt;u&gt;想要画上下划线的内容&lt;/u&gt;
    下面使用&quot;~~请无视这句话~~&quot;以及&quot;&lt;u&gt;划重点啦&lt;/u&gt;&quot;来演示效果：
</code></pre>
<p>&emsp;&emsp;&emsp;<del>请无视这句话</del> &emsp; <u>划重点啦</u></p>
<h3 id="6-空格"><a href="#6-空格" class="headerlink" title="6. 空格"></a>6. 空格</h3><pre><code>    一种打空格的方式是直接按space键或者tab键，但是为了更好地控制空白
的大小，可以使用html当中的空格：
    可以用&quot;&amp;nbsp;&quot;或者&quot;&amp;ensp;&quot;或者&quot;&amp;emsp&quot;等不同定义的空格来实现想
要的空白宽度，具体可以参照这篇博客：html空格的五种表示(https://www.
cnblogs.com/SimonHu1993/p/9257176.html)。
    下面使用&quot;|&amp;nbsp|---------|&amp;ensp|---------|&amp;emsp;|&quot;来演示这
三种空格的大小：
</code></pre>
<p>&emsp;&emsp;&emsp;|&nbsp;|———|&ensp;|———|&emsp;|</p>
<h2 id="四-markdown语法之链接与引用"><a href="#四-markdown语法之链接与引用" class="headerlink" title="四. markdown语法之链接与引用"></a>四. markdown语法之链接与引用</h2><h4 id="1-自动链接"><a href="#1-自动链接" class="headerlink" title="1. 自动链接"></a>1. 自动链接</h4><pre><code>    自动链接就是将地址原封不动的显示出来，同时它也将生成该地址的超链接，
它常用于邮箱地址和较短网址的显示。语法是在该链接地址前后加上一对&lt; &gt;，常
用于显示邮箱或者网址等等。
    比如，使用代码&quot;&lt;https://github.com/&gt;&quot;可以生成如下的自动链接：
</code></pre>
<p>&emsp;&emsp;&emsp;<a href="https://github.com/">https://github.com/</a></p>
<h4 id="2-文本链接"><a href="#2-文本链接" class="headerlink" title="2. 文本链接"></a>2. 文本链接</h4><pre><code>    markdown支持行内式(inline)和参考式(reference)两种形式的超文本链
接语法格式。不管是哪一种，链接文字都是用方括号&quot;[]&quot;来标记。
    首先是行内式，其markdown语法为&quot;[txt](url)&quot;，对应html语法为&lt;a hr
ef=&quot;url&quot;&gt;text&lt;/a&gt;。如果你还想要加上链接的title，只要在网址后面用双引
号把title文字包起来即可。
    然后是参考式，其用途主要是可以先声明超链接但是并不给出其定义，而是在
md文件的任何其他位置(一般是末尾)加以定义。其markdown语法为：先定义参考
refid：[text][refid]，再定义参考refid所指向的具体地址[refid]:url。
注意，这里有一些简写和细节问题，详情可以参考下述用于演示参考式的链接里的
博客。
    以下我们用html语法&lt;a href=&quot;https://starlooo.github.io/&quot;&gt;我的
博客主页&lt;/a&gt;来演示行内式文编链接；然后用markdown语法[一篇关于链接的参
考博客][ref_blog_1]和[ref_blog_1]:https://blog.csdn.net/baox
iao7872/article/details/90240402来演示参考式文本链接：
</code></pre>
<p>&emsp;&emsp;&emsp;<a href="https://starlooo.github.io/">我的博客主页</a><br><br>&emsp;&emsp;&emsp;<a href="https://blog.csdn.net/baoxiao7872/article/details/90240402">一篇关于链接的参考博客</a></p>
<h4 id="3-图片链接"><a href="#3-图片链接" class="headerlink" title="3. 图片链接"></a>3. 图片链接</h4><pre><code>    markdown使用与文本链接几乎相同的方式来实现图片链接，同样支持行内式
和参考式两种形式，只是需要在方括号前加上一个&quot;!&quot;。
    以行内式为例，图片链接的markdown语法为：![alt_txt](url)，对应ht
ml写法为&lt;img src=&quot;url&quot; alt=&quot;text&quot;&gt;，其中文本部分可选，如果没有需要可
以不写。
    但这里有个问题，我目前虽然可以把本地的图片链接入markdown，但当写博
客部署到云端后却发现图片无法加载。目前的解决方法是使用图床，将自己本地的
图片上传到网上，然后生成链接来引用。下面提供的链接的知乎回答里有关于一些
图床的介绍，读者可以自行选用。
    以下我们分别用markdown语法：[illustration_1](https://z3.ax1x
.com/2021/05/08/gGdtld.jpg)]和html语法&lt;img src=&quot;https://z3.ax1
x.com/2021/05/09/gYI9n1.jpg&quot; alt=&quot;gYI9n1.jpg&quot; border=&quot;0&quot; /&gt;来
演示图片链接：
</code></pre>
<p><img src="https://z3.ax1x.com/2021/05/08/gGdtld.jpg" alt="illustration_1"><br><img src="https://z3.ax1x.com/2021/05/09/gYI9n1.jpg" alt="illustrtion_2"></p>
<h4 id="4-块引用"><a href="#4-块引用" class="headerlink" title="4. 块引用"></a>4. 块引用</h4><pre><code>    markdown可以创建块引用，具体方法是在段落前添加一个&quot;&gt;&quot;，如果需要对
多个段落添加块引用需要在空行前也加上&quot;&gt;&quot;。
    同时，块引用可以嵌套使用，可以在一级块引用内使用&quot;&gt;&gt;&quot;创建二级块引用。
另一方面块引用的内部也可以使用markdown的其他语法元素，具体可以自行尝试。
    以下我们用&gt;**块引用段落1**&lt;br&gt;和&gt;*块引用段落2*&lt;br&gt;以及&gt;&gt;&lt;mark&gt;
嵌套块引用&lt;mark&gt;引用来演示块引用：
</code></pre>
<blockquote>
<p><strong>块引用段落1</strong><br><br><em>块引用段落2</em><br></p>
<blockquote>
<p><mark>嵌套块引用<mark></p>
</blockquote>
</blockquote>
<h4 id="5-代码和代码块"><a href="#5-代码和代码块" class="headerlink" title="5. 代码和代码块"></a>5. 代码和代码块</h4><pre><code>    markdown中可以标记行内代码，具体方法是使用一对反引号&quot;`&quot;将想要写的代码
框住，或者使用html语法中的&lt;code&gt;inline_code&lt;code&gt;。
    此外，markdown可以创建代码块，具体方法是在段代码块的每一行前缩进4个空
格或者1个制表符。另以种方式是把代码块框在一对“```”或者&quot;~~~&quot;之内。另外，根
据我的实验，使用4个空格或1个制表符的方式与使用3个反引号或波浪号框住的方式的
区别在于后者创建的代码块会标上行号。
    以下我们用&quot;`printf()`函数是C语言的基本输出函数&quot;和一段写有HelloMarkd
own程序的代码块来演示：
</code></pre>
<p><code>printf()</code>函数是C语言的基本输出函数<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Hello, markdown!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-markdown语法之列表与表格"><a href="#五-markdown语法之列表与表格" class="headerlink" title="五. markdown语法之列表与表格"></a>五. markdown语法之列表与表格</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1. 无序列表"></a>1. 无序列表</h3><pre><code>    可以使用在行首加上&quot;-&quot;或&quot;+&quot;或&quot;*&quot;标记的方式创建markdown无序列表。所谓
无序列表，指的是各表项间是并列关系，并没有相对先后顺序。渲染结果是一个小圈。
    此外可以在无序列表内部用同样的方式创建嵌套的无序列表。
    以下代码用来演示无序列表的创建:
    * 无序列表的演示,表项1
        - 无序列表的演示，子表项1
        + 无序列表的演示，子表项2

    * 无序列表的演示,表项2
</code></pre>
<ul>
<li>无序列表的演示,表项1<ul>
<li>无序列表的演示，子表项1</li>
</ul>
<ul>
<li>无序列表的演示，子表项2</li>
</ul>
</li>
<li>无序列表的演示,表项2        </li>
</ul>
<h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2. 有序列表"></a>2. 有序列表</h3><pre><code>    可以使用在行首加上”x.“标记的方式创建markdown有序列表，其中x为相应数字。
所谓有序列表，指的是各表项间是递进关系，有相对先后顺序。渲染结果是一个从1开始
按顺序拍下去的各表项，而子表项用排序渲染出的是对应罗马数字。
    此外可以在有序列表用相同的方式创建嵌套的有序列表，甚至可以用创建无序列表
的方式嵌套无序列表，反之亦然。
    以下代码用来演示有序列表的创建:
    1. 有序列表的演示,表项1
        1. 有序列表的演示，子表项1
        2. 有序列表的演示，子表项2

    2. 有序列表的演示,表项2
</code></pre>
<ol>
<li><p>有序列表的演示,表项1</p>
<ol>
<li>有序列表的演示，子表项1</li>
<li>有序列表的演示，子表项2</li>
</ol>
</li>
<li><p>有序列表的演示,表项2</p>
</li>
</ol>
<h3 id="3-表格"><a href="#3-表格" class="headerlink" title="3. 表格"></a>3. 表格</h3><pre><code>    markdown支持使用&quot;|&quot;分割各表格项以及标记表格的行首行尾的方式创建表格，其中
行首行尾的&quot;|&quot;可以省略。第一行一般用于写每列的列名，列名采取居中对齐方式。
    在对齐方面，可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，可以在
相应位置写入&quot;-:&quot;表示这列的文字采用右对齐，同理&quot;:-&quot;表示左对齐，&quot;:-:&quot;表示居中对
齐。此外，需要注意创建表格时需要与上一段有一个空行，不然无法被识别。
    不知道是什么原因，在我使用IDEA编写md文件时，第二行里如果只使用一个&quot;-&quot;的话
实时渲染的结果并没有创建出对应表格，但实际上部署到云端博客的时候是创建了相应表格
的。但为了本地测试方便，我还是写了3个以上的&quot;-&quot;让IDEA识别出表格。
    以下代码用来演示创建表格：
    | 左对齐列 | 右对齐列 | 居中对齐列 |
    | :------| ------: | :------: |
    | 短文本 | 中等文本 | 稍微长一点的文本 |
    | 稍微长一点的文本 | 短文本 | 中等文本 |
</code></pre>
<table>
<thead>
<tr>
<th align="left">左对齐列</th>
<th align="right">右对齐列</th>
<th align="center">居中对齐列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">短文本</td>
<td align="right">中等文本</td>
<td align="center">稍微长一点的文本</td>
</tr>
<tr>
<td align="left">稍微长一点的文本</td>
<td align="right">短文本</td>
<td align="center">中等文本</td>
</tr>
</tbody></table>
<p>以下是两篇有关于markdown表格的参考博客:</p>
<p><a href="https://www.jianshu.com/p/2df05f279331">Markdown插入表格语法</a></p>
<p><a href="https://blog.csdn.net/tuxingchen6/article/details/55222951">利用Markdown创建表格</a></p>
]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>markdown</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类学习笔记序章</title>
    <url>/2021/05/19/collection_0/</url>
    <content><![CDATA[<h1 id="Java集合类学习笔记序章"><a href="#Java集合类学习笔记序章" class="headerlink" title="Java集合类学习笔记序章"></a><center>Java集合类学习笔记序章</center></h1><h2 id="一-系列简介"><a href="#一-系列简介" class="headerlink" title="一. 系列简介"></a>一. 系列简介</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在软件构造课程的学习过程中，对Java编程语言的不断</span>
<span style="font-size: 20px">
学习和练习是至关重要的。其中，通过对于Java JDK当中提供的各种各</span>
<span style="font-size: 20px">
样的容器的使用方法的学习能够极大地提高我们的编程能力。而JDK中</span>
<span style="font-size: 20px">
最常用的一类容器，莫过于<a href="https://docs.oracle.com/javase
/8/docs/api/java/util/Collection.html">集合Collection</a>了。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;因此，在学习Java Collection接口以及各个常见的实现类的过程当</span>
<span style="font-size: 20px">
中，撰写一系列博客来记录学习的过程和心得体会是有必要的。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;然而，由于Java集合及其各种实现类源码本身涉及到复杂的Java语法，</span>
<span style="font-size: 20px">
比如多线程、注解等，以及其具体实现的精妙性、复杂性，<mark>很难保证该系列博客中记录的我个人的理解是正确无误的。</mark><br></span>
<span style="font-size: 20px">
&emsp;&emsp;此外，受限于个人对Java的理解水平有限，以及时间精力等多重因素的</span>
<span style="font-size: 20px">
限制，所以<mark>一些细节的部分无法做到面面俱到，只是对一些学习到的知识随手记录</mark>，</span>
<span style="font-size: 20px">
系统性和逻辑性都略有不足。可做抛砖引玉之用。<br></span>
</div>

<span id="more"></span>

<h2 id="二-系列博客的内容组成"><a href="#二-系列博客的内容组成" class="headerlink" title="二. 系列博客的内容组成"></a>二. 系列博客的内容组成</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在我的预想中，接下来这一系列博客将基本按以下的方式进行组织： <br></span>
<span style="font-size: 20px">
&emsp;&emsp;首先是命名，除了本章序章以外，基本按照第一章XX、第二章XX这样的方式</span>
<span style="font-size: 20px">
依次命名下去。其中XX是具体对此章内容的总体概括。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;然后是具体的各章内容，目前是这样计划的：<br>
&emsp;&emsp;(1)<br>&emsp;&emsp;&emsp;&emsp;首先是<a href="http://localhost:4000/2021/05/19/collection_0/">序章</a></span>
<span style="font-size: 20px">对系列博客的基本介绍以及为一些关键的说明作预留，以及一些可能<br></span>
<span style="font-size: 20px">&emsp;&emsp;有用的参考的资料的整理。<br>
&emsp;&emsp;(2)<br>&emsp;&emsp;&emsp;&emsp;然后是<a href="http://localhost:4000/2021/05/19/collection_1/">第一章</a></span>
<span style="font-size: 20px">，用来介绍Java迭代器接口Iterator和可迭代接口Iterable，他们对于<br></span>
<span style="font-size: 20px">&emsp;&emsp;后续集合的遍历非常有用，因此在第一章，我们尽可能将</span>
<span style="font-size: 20px">其常见的使用方法一网打尽。<br>
&emsp;&emsp;(3)<br>&emsp;&emsp;&emsp;&emsp;然后是第三章，正式进入对集合的整理，在这一章我们将</span>
<span style="font-size: 20px">对Collection接口中的所<br>
&emsp;&emsp;有抽象方法做详细理解，并通过其各种实现类进行相应的测试。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;(4)<br>&emsp;&emsp;&emsp;&emsp;然后是第三、四、五章，在这几章我们将</span>
<span style="font-size: 20px">对Collection接口的常见实现类中的中的<br>
&emsp;&emsp;常用方法做详细理解，并进行相应的测试，也会涉及到相当一些源码的阅读分析。<br></span>
<span style="font-size: 20px">
&emsp;&emsp;(5)<br>&emsp;&emsp;&emsp;&emsp;To Be Continued!<br></span>
</div>

<h2 id="三-参考资料汇总"><a href="#三-参考资料汇总" class="headerlink" title="三. 参考资料汇总"></a>三. 参考资料汇总</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;<a href="https://docs.oracle.com/javase/8/docs/api/">Java JDK8官方API英文版</a><br>
&emsp;&emsp;<a href="https://www.matools.com/api/java8">Java JDK8官方API中文版</a></span>
<span style="font-size: 20px"><mark>(注意，机翻质量极低，不建议大量使用)</mark><br>
&emsp;&emsp;<a href="https://blog.csdn.net/u011240877/category_6447444.html">
一系列关于Java集合框架的原理分析博客</a>&emsp;&emsp;作者：拭心<br></span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;<br></span>
<span style="font-size: 20px">
&emsp;&emsp;</span>
<span style="font-size: 20px">
&emsp;&emsp;<br></span>
</div>



]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合类学习笔记第一章--迭代器</title>
    <url>/2021/05/21/collection_1/</url>
    <content><![CDATA[<h1 id="Java集合类学习笔记第一章–迭代器"><a href="#Java集合类学习笔记第一章–迭代器" class="headerlink" title="Java集合类学习笔记第一章–迭代器"></a><center>Java集合类学习笔记第一章–迭代器</center></h1><h2 id="一-本章概述"><a href="#一-本章概述" class="headerlink" title="一. 本章概述"></a>一. 本章概述</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;在本章中，主要介绍Java迭代器的有关内容。<br>
&emsp;&emsp;要讲集合，首先得讲清楚迭代器。在JDK中可以从接口声明中清楚的看到<a href="https://doc
s.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>接口继承自</span>
<span style="font-size: 20px">
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterable.html">Iterable</a>接口。<br>
&emsp;&emsp;而迭代器<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">
Iterator</a>接口</span>
<span style="font-size: 20px">,具体到其在各种集合类中对应的实现，为我们提供了有效地访问、遍历不同类型的集合中元素的方法。<br>
&emsp;&emsp;因此，我把对Iterable和Iterator这两个接口的学习放到了第一章。本章的学习目的为：</span>
<span style="font-size: 20px">
基本掌握Java迭代器在集合类当中的使用，同时对迭代器使用过程中的有关注意事项有一个清楚的认知。<br></span></div>

<span id="more"></span>

<h2 id="二-迭代器接口和可迭代接口的基本介绍"><a href="#二-迭代器接口和可迭代接口的基本介绍" class="headerlink" title="二. 迭代器接口和可迭代接口的基本介绍"></a>二. 迭代器接口和可迭代接口的基本介绍</h2><div style="font-size: 0">
<span style="font-size: 20px">
&emsp;&emsp;根据官方API中对Iterable可迭代接口的说明:"Implementing this interface allows an object to be the target </span>
<span style="font-size: 20px">of the "for-each loop" statement."，实现了Iterable接口的对象就可以使用for-each循环。那么，</span>
<span style="font-size: 20px">什么是for-each循环呢?<br>
&emsp;&emsp;for-each循环，又称增强for循环，是JDK5的新特性中定义的一种新的循环语法，语法的标准格式为：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for( 数据类型 变量名 : 遍历的目标对象 ) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;最常见的比如数组就支持for-each循环，以下是用普通for循环和增强for循环对数组遍历的示例程序：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void loopTest() &#123;</span><br><span class="line">    int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">    System.out.println(&quot;普通for循环:&quot;);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;\n增强for循环:&quot;);</span><br><span class="line">    for(int num : arr) &#123;</span><br><span class="line">        System.out.print(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="font-size: 20px">&emsp;&emsp;执行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/20/gIgQP0.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;根据官方API，Iterable接口中的定义为：<code>public Interface Iterable&lt;T&gt;</code>，内部的抽象方法只有一个:</span>
<span style="font-size: 20px"><code>Iterator&lt;T&gt;iterator()</code></span>
<span style="font-size: 20px">其作用为返回一个元素类型为T的迭代器。所有实现了Iterable的接口都实现了这个方法，特别的，集合也是。<br>
&emsp;&emsp;接着我们看看Iterator接口的API，接口定义为：<code>public Interface Iterator<&#917;></code>。官方文档对其有如下的解释：
<br>&emsp;&emsp;Iterator是用来替代原来集合框架中的<a href="">Enumeration</a>接口的，</span>
<span style="font-size: 20px">其相比Enumeration接口，有以下两个变化：其一是迭代器允许调用者在迭代过程中使用定义明确的语义</span>
<span style="font-size: 20px">从集合中删除元素；其二是对方法的命名有所改进。第一点中所谓定义明确的语义，听起来有点费解</span>
<span style="font-size: 20px">我们会在接下来的小节研究这一部分的内容，这里就先跳过了。<br>
&emsp;&emsp;Iterator中声明了两个抽象方法和两个默认方法，其中最重要也是最常用的三个方法分别为：<br>
&emsp;&emsp;<code>boolean hasNext()</code> ，作用为判断迭代是否还有下一个元素。换句话说，当该方法返回true时，调用next方法</span>
<span style="font-size: 20px">会返回下一个元素而不是抛出异常<br>
&emsp;&emsp;<code>E    next()</code> ，作用为返回迭代的下一个元素，如果迭代已经没有下一个元素了，则会抛出NoSuchElementException。<br>
&emsp;&emsp;<code>default void remove()</code> ，作用为从集合中移除此迭代器最近返回的那个元素。</span>
<span style="font-size: 20px">关于该默认方法有一些注意事项，我们会在第三小节中详细说明。<br></span>
</div>


<h2 id="三-Iterator接口的详细介绍"><a href="#三-Iterator接口的详细介绍" class="headerlink" title="三. Iterator接口的详细介绍"></a>三. Iterator接口的详细介绍</h2><div style="font-size: 20px">
&emsp;&emsp;下面仔细研究一下Iterator接口中的这三个方法，使用集合类中大家最熟悉的ArrayList做测试。<br></div>

<h3 id="part1–hasNext方法"><a href="#part1–hasNext方法" class="headerlink" title="part1–hasNext方法"></a>part1–hasNext方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns true if the iteration has more elements.</mark></span>
<span style="font-size: 20px"><mark>(In other words, returns true if next() would return an element
rather than throwing an exception.)</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void hasNextTest() &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">        Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        arraylist.add(1);</span><br><span class="line">        &#x2F;&#x2F;重新获得arraylist的迭代器</span><br><span class="line">        it &#x3D; arraylist.iterator();</span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;空迭代器调用hasNext方法会抛出NullPointerException</span><br><span class="line">        ArrayList&lt;Integer&gt; null_arr &#x3D; null;</span><br><span class="line">        Iterator&lt;Integer&gt; null_it &#x3D; null_arr.iterator();</span><br><span class="line">        System.out.println(null_it.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZYnA.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，第一次获取arraylist的迭代器的时候，arraylist为空，所以it.hasNext输出为false; 而第二次获取arraylist</span>
<span style="font-size: 20px">迭代器的时候，arraylist中有一个元素1，所以it.hasNext输出为true; 接着我们定义了一个空的ArrayList对象，</span>
<span style="font-size: 20px">获得了它的迭代器，此时这个迭代器为空，若对空迭代器调用hasNext方法，则会产生NullPointerException异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h3 id="part2–next方法"><a href="#part2–next方法" class="headerlink" title="part2–next方法"></a>part2–next方法</h3><div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;官方API中对其描述为：<br>&emsp;&emsp;<mark>Returns the next element in the iteration.</mark></span>
<span style="font-size: 20px"><mark>Throws NoSuchElementException if the iteration has no more elements.</mark><br>
&emsp;&emsp;我们来测试一下：<br></span></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void nextTest() &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    arraylist.add(1);</span><br><span class="line">    arraylist.add(2);</span><br><span class="line">    arraylist.add(3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得arraylist的迭代器</span><br><span class="line">    Iterator&lt;Integer&gt; it &#x3D; arraylist.iterator();</span><br><span class="line"></span><br><span class="line">    while(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果it.hasNext()为false的时候调用it.next会产生NoSuchElementException</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="font-size: 20px">&emsp;&emsp;运行结果如下：<br></span><br><img src="https://z3.ax1x.com/2021/05/21/g7ZIc4.png" alt="illustration_1"></p>
<div style="font-size: 0"><span style="font-size: 20px">
&emsp;&emsp;可以看到，在while循环的循环判断中，我们使用it.hasNext()来判断迭代是否有下一个元素，当迭代有下个元素的时候，</span>
<span style="font-size: 20px">我们再调用it.next()，此时可以保证it.next()返回的是下一个元素而不会抛出异常。</span>
<span style="font-size: 20px"><mark>这也是一种标准的非常建议的迭代器的使用方法</mark>，我们会在第四节中再提及这一点。<br>
&emsp;&emsp;根据打印结果，说明每次调用next()方法，在得到下一个元素的同时，迭代器的位置都会发生移动，使得下一次调用next()方法的时候</span>
<span style="font-size: 20px">迭代的下一个元素(如果有的话)是当前next()返回元素的下一个。具体到示例程序中，就是依次返回1、2、3。<br>
&emsp;&emsp;接着，程序退出while循环，说明hasNext()返回值为false，此时迭代到了末尾，已经没有下一个元素了，如果此时调用next()方法</span>
<span style="font-size: 20px">就会像API中规定的那样，抛出NoSuchElement异常。<br>
&emsp;&emsp;以上便是对hasNext方法的测试分析。<br></span></div>

<h2 id="四-ListIterator简介"><a href="#四-ListIterator简介" class="headerlink" title="四. ListIterator简介"></a>四. ListIterator简介</h2><h2 id="五-参考资料"><a href="#五-参考资料" class="headerlink" title="五. 参考资料"></a>五. 参考资料</h2>]]></content>
      <categories>
        <category>我的笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
</search>
